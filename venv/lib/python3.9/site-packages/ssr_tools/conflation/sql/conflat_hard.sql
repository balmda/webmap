
-----------
-- conflation
-----------
-- This is a process to conflate one spatial source dataset (e.g., received.posted_speed) onto a target dataset (e.g. automated.segments) 
-- reading source features
-- create a smaller copy of the data with the attributes you want joined to the target data
DROP TABLE IF EXISTS tmp_source;
CREATE TEMP TABLE tmp_source AS (
SELECT
    p_key AS id,--make parameter
    geom,
    description AS attr --make parameter
FROM received.lrs_federal_functional_class--make parameter
);

-- create indices
ALTER TABLE tmp_source ADD PRIMARY KEY (id);
CREATE INDEX idx_tmp_source_id ON tmp_source USING BTREE (id);
CREATE INDEX gist_source_geom ON tmp_source USING GIST (geom);
ANALYZE tmp_source;

-- reading target features
-- create a smaller copy of the target that you want the source data joined to
DROP TABLE IF EXISTS tmp_target;
CREATE TEMP TABLE tmp_target AS (
SELECT
    p_key AS id,--make parameter
    geom
FROM automated.windows_urban --make parameter
WHERE any_crash
);

ALTER TABLE tmp_target ADD PRIMARY KEY (id);
CREATE INDEX idx_tmp_target_id ON tmp_source USING BTREE (id);
CREATE INDEX gist_target_geom ON tmp_target USING GIST (geom);
ANALYZE tmp_target;

DROP TABLE IF EXISTS tmp_cuts;
CREATE TEMP TABLE tmp_cuts AS (
SELECT
    t.id AS target_id,
    s.id AS source_id,
    s.attr,
    t.geom AS target_geom,
    ST_Intersection(ST_Buffer(t.geom, 50,'endcap=flat'), s.geom) AS source_geom --make buffer distance a parameter
FROM
    tmp_target t,
    tmp_source s
WHERE ST_Length(t.geom) > 5 --make length a parameter
AND ST_DWithin(t.geom, s.geom, 50) --make distance a parameter
);

ALTER TABLE tmp_cuts ADD COLUMN id SERIAL PRIMARY KEY;
CREATE INDEX idx_tmp_cuts_id ON tmp_cuts USING BTREE (id);
CREATE INDEX gist_tmp_cuts_target_geom ON tmp_cuts USING GIST (target_geom);
CREATE INDEX gist_tmp_cuts_source_geom ON tmp_cuts USING GIST (source_geom);
ANALYZE tmp_cuts;


-- isolate all possible matches
-- uses hausdorff distance and filters our any potential pairs in the angle between the pairs are above a user provided threshold
DROP TABLE IF EXISTS tmp_conflate;
CREATE TEMP TABLE tmp_conflate AS (
SELECT 
    DISTINCT ON (target_id)
    target_id,
    source_id,
    attr,
    ST_HausdorffDistance(target_geom, source_geom) AS score
FROM tmp_cuts
WHERE degrees(acos(abs(cos(ST_Azimuth(
                            ST_StartPoint(target_geom),
                            ST_EndPoint(target_geom)
                            ) -
                            ST_Azimuth(
                                ST_StartPoint(source_geom),
                                ST_EndPoint(source_geom)
                            ))))) <= 60 --make parameter
ORDER BY target_id, score ASC
);

ALTER TABLE tmp_conflate ADD PRIMARY KEY (target_id);
CREATE INDEX idx_tmp_cuts_target_id ON tmp_cuts USING BTREE (target_id);
ANALYZE tmp_conflate;

-- save the conflated matched segments
-- this does not include the failed matched target features
DROP TABLE IF EXISTS  scratch.testing_conf;--make parameter
CREATE TABLE scratch.testing_conf AS (--make parameter
SELECT
    tmp_conflate.target_id,
    target.geom,
    tmp_conflate.source_id,
    tmp_conflate.attr AS description,
    tmp_conflate.score
FROM
    tmp_conflate,
    automated.windows_urban  target--make parameter
WHERE tmp_conflate.score < 9999 --make parameter
AND target.p_key= tmp_conflate.target_id
);

ALTER TABLE scratch.testing_conf ADD PRIMARY KEY (target_id);--make parameter
ALTER TABLE scratch.testing_conf ADD COLUMN id SERIAL PRIMARY KEY;--make parameter
CREATE INDEX idx_scratch_testing_conf_id ON scratch.testing_conf USING BTREE (id);--make parameter
CREATE INDEX gist_scratch_testing_conf_geom ON scratch.testing_conf USING GIST (geom);--make parameter
ANALYZE scratch.testing_conf;--make parameter
----------------
-- fill gaps
----------------
-- same as initial conflation effort
DROP TABLE IF EXISTS tmp_source;
CREATE TEMP TABLE tmp_source AS (
SELECT
    p_key AS id,--make parameter
    geom,
    description AS attr --make parameter
FROM received.lrs_federal_functional_class--make parameter
);

ALTER TABLE tmp_source ADD PRIMARY KEY (id);
CREATE INDEX idx_tmp_source_id ON tmp_source USING BTREE (id);
CREATE INDEX gist_source_geom ON tmp_source USING GIST (geom);
ANALYZE tmp_source;

-- same as initial conflation effort
DROP TABLE IF EXISTS tmp_target;
CREATE TEMP TABLE tmp_target AS (
SELECT
    p_key AS id,--make parameter
    geom
FROM  automated.windows_urban --make parameter
WHERE p_key NOT IN (SELECT target_id FROM scratch.testing_conf)--make parameter
);

ALTER TABLE tmp_target ADD PRIMARY KEY (id);
CREATE INDEX idx_tmp_target_id ON tmp_source USING BTREE (id);
CREATE INDEX gist_target_geom ON tmp_target USING GIST (geom);
ANALYZE tmp_target;

-- matched results from initial conflation
DROP TABLE IF EXISTS tmp_filled;
CREATE TEMP TABLE tmp_filled AS (
SELECT
    target_id,
    geom
FROM scratch.testing_conf--make parameter
);

ALTER TABLE tmp_filled ADD PRIMARY KEY (target_id);
CREATE INDEX idx_tmp_filled_target_id ON tmp_filled USING BTREE (target_id);
CREATE INDEX gist_tmp_filled_geom ON tmp_filled USING GIST (geom);
ANALYZE tmp_filled;

-- Similar conflation process but buffers from already conflation segments too
DROP TABLE IF EXISTS tmp_fill_gaps;
CREATE TEMP TABLE tmp_fill_gaps AS (
SELECT
    DISTINCT ON (gap.id)
    gap.id,
    tmp_source.attr,
    tmp_source.id AS source_id
FROM 
    tmp_target gap,
    tmp_filled,
    tmp_source
WHERE ST_DWithin(gap.geom, tmp_source.geom, 50)--make buffer a parameter
AND ST_DWithin(ST_LineInterpolatePoint(gap.geom, 0.5), tmp_source.geom, 50)--make buffer a parameter
AND ST_DWithin(gap.geom, tmp_filled.geom,50)--make buffer a parameter
AND degrees(acos(abs(cos(ST_Azimuth(
                            ST_StartPoint(gap.geom),
                            ST_EndPoint(gap.geom)
                        ) -
                        ST_Azimuth(
                            ST_StartPoint(tmp_source.geom),
                            ST_EndPoint(tmp_source.geom)
                        ))))) <= 60 --make parameter
ORDER BY gap.id, ST_Distance(ST_LineInterpolatePoint(gap.geom, 0.5), tmp_source.geom) ASC
);

ALTER TABLE tmp_fill_gaps ADD PRIMARY KEY (id);
CREATE INDEX idx_tmp_fill_gaps_id ON tmp_fill_gaps USING BTREE (id);
CREATE INDEX gist_tmp_filled_gaps_geom ON tmp_fill_gaps USING GIST (geom);
ANALYZE tmp_fill_gaps;

-- insert filled gaps into original conflated matched 
INSERT INTO scratch.testing_conf--make parameter
SELECT
    tmp_fill_gaps.id,
    target.geom,
    tmp_fill_gaps.source_id,
    tmp_fill_gaps.attr AS description,
    NULL
FROM
    tmp_fill_gaps,
    automated.windows_urban target--make parameter
WHERE target.p_key = tmp_fill_gaps.id
;