
-----------;
-- conflation;
-----------;
-- This is a process to conflate one spatial source dataset (e.g., received.posted_speed) onto a target dataset (e.g. automated.segments);
-- reading source features;
-- create a smaller copy of the data with the attributes you want joined to the target data;
DROP TABLE IF EXISTS tmp_source;
CREATE TEMP TABLE tmp_source AS 
SELECT
    {source_pkid} AS id,
    {source_geom} AS geom,
    {source_column} AS attr 
FROM {source_schema}.{source_table}
WHERE {source_filter}
;

-- create indices;
ALTER TABLE tmp_source ADD PRIMARY KEY (id);
CREATE INDEX idx_tmp_source_id ON tmp_source USING BTREE (id);
CREATE INDEX gist_source_geom ON tmp_source USING GIST (geom);
ANALYZE tmp_source;

-- reading target features;
-- create a smaller copy of the target that you want the source data joined to;
DROP TABLE IF EXISTS tmp_target;
CREATE TEMP TABLE tmp_target AS 
SELECT
    {target_pkid} AS id,
    {target_geom} AS geom
FROM {target_schema}.{target_table}
WHERE {target_filter}
;

ALTER TABLE tmp_target ADD PRIMARY KEY (id);
CREATE INDEX idx_tmp_target_id ON tmp_source USING BTREE (id);
CREATE INDEX gist_target_geom ON tmp_target USING GIST (geom);
ANALYZE tmp_target;

-- buffer and cut pairs;
DROP TABLE IF EXISTS tmp_cuts;
CREATE TEMP TABLE tmp_cuts AS 
SELECT
    t.id AS target_id,
    s.id AS source_id,
    s.attr,
    t.geom AS target_geom,
    ST_Intersection(ST_Buffer(t.geom, {tolerance},'endcap=flat'), s.geom) AS source_geom 
FROM
    tmp_target t,
    tmp_source s
WHERE ST_Length(t.geom) > {min_length} 
AND ST_DWithin(t.geom, s.geom, {tolerance}) 
;

ALTER TABLE tmp_cuts ADD COLUMN id SERIAL PRIMARY KEY;
CREATE INDEX idx_tmp_cuts_id ON tmp_cuts USING BTREE (id);
CREATE INDEX gist_tmp_cuts_target_geom ON tmp_cuts USING GIST (target_geom);
CREATE INDEX gist_tmp_cuts_source_geom ON tmp_cuts USING GIST (source_geom);
ANALYZE tmp_cuts;


-- isolate all possible matches;
-- uses hausdorff distance and filters our any potential pairs in the angle between the pairs are above a user provided threshold;
DROP TABLE IF EXISTS tmp_conflate;
CREATE TEMP TABLE tmp_conflate AS 
SELECT 
    DISTINCT ON (target_id)
    target_id,
    source_id,
    attr,
    ST_HausdorffDistance(target_geom, source_geom) AS score
FROM tmp_cuts
WHERE degrees(acos(abs(cos(ST_Azimuth(
                            ST_StartPoint(target_geom),
                            ST_EndPoint(target_geom)
                            ) -
                            ST_Azimuth(
                                ST_StartPoint(source_geom),
                                ST_EndPoint(source_geom)
                            ))))) <= {max_angle} 
ORDER BY target_id, score ASC
;

ALTER TABLE tmp_conflate ADD PRIMARY KEY (target_id);
CREATE INDEX idx_tmp_cuts_target_id ON tmp_cuts USING BTREE (target_id);
ANALYZE tmp_conflate;

-- save the conflated matched segments;
-- this does not include the failed matched target features;
DROP TABLE IF EXISTS {schema}.{table} ;
CREATE TABLE {schema}.{table}  AS 
SELECT
    tmp_conflate.target_id,
    target.{target_geom},
    tmp_conflate.source_id,
    tmp_conflate.attr AS {source_column},
    tmp_conflate.score
FROM
    tmp_conflate,
    {target_schema}.{target_table}  target
WHERE tmp_conflate.score < {max_score} 
AND target.{target_pkid} = tmp_conflate.target_id
;

-- ALTER TABLE {schema}.{table} ADD PRIMARY KEY (target_id);
-- ALTER TABLE {schema}.{table} ADD COLUMN id SERIAL PRIMARY KEY;
-- CREATE INDEX idx_{schema}_{table}_conf_id ON {schema}.{table} USING BTREE (id);
-- CREATE INDEX gist_{schema}_{table}_conf_geom ON {schema}.{table} USING GIST (geom);
-- ANALYZE {schema}.{table} ;

----------------;
-- fill gaps;
----------------;
-- same as initial conflation effort but only include non-matched segments ;
DROP TABLE IF EXISTS tmp_target CASCADE;
CREATE TEMP TABLE tmp_target AS 
SELECT
    {target_pkid} AS id,
    {target_geom} AS geom
FROM {target_schema}.{target_table}
WHERE {target_pkid} NOT IN (SELECT target_id FROM {schema}.{table})
AND {target_filter}
;

ALTER TABLE tmp_target ADD PRIMARY KEY (id);
DROP INDEX IF EXISTS idx_tmp_target_id;
CREATE INDEX idx_tmp_target_id ON tmp_source USING BTREE (id);
DROP INDEX IF EXISTS gist_target_geom;
CREATE INDEX gist_target_geom ON tmp_target USING GIST (geom);
ANALYZE tmp_target;

-- matched results from initial conflation;
DROP TABLE IF EXISTS tmp_filled;
CREATE TEMP TABLE tmp_filled AS 
SELECT
    target_id,
    {target_geom} 
FROM {schema}.{table}
;

ALTER TABLE tmp_filled ADD PRIMARY KEY (target_id);
CREATE INDEX idx_tmp_filled_target_id ON tmp_filled USING BTREE (target_id);
CREATE INDEX gist_tmp_filled_geom ON tmp_filled USING GIST (geom);
ANALYZE tmp_filled;

-- Similar conflation process but buffers from already conflation segments too;
DROP TABLE IF EXISTS tmp_fill_gaps;
CREATE TEMP TABLE tmp_fill_gaps AS 
SELECT
    DISTINCT ON (gap.id)
    gap.id,
    tmp_source.attr,
    tmp_source.id AS source_id
FROM 
    tmp_target gap,
    tmp_filled,
    tmp_source
WHERE ST_DWithin(gap.geom,tmp_source.geom,{tolerance})
AND ST_DWithin(ST_LineInterpolatePoint(gap.geom,0.5),tmp_source.geom,{tolerance})
AND ST_DWithin(gap.geom,tmp_filled.geom,{tolerance})
AND degrees(acos(abs(cos(ST_Azimuth(
                            ST_StartPoint(gap.geom),
                            ST_EndPoint(gap.geom)
                        ) -
                        ST_Azimuth(
                            ST_StartPoint(tmp_source.geom),
                            ST_EndPoint(tmp_source.geom)
                        ))))) <= 60 
ORDER BY gap.id, ST_Distance(ST_LineInterpolatePoint(gap.geom, 0.5), tmp_source.geom) ASC
;

ALTER TABLE tmp_fill_gaps ADD PRIMARY KEY (id);
CREATE INDEX idx_tmp_fill_gaps_id ON tmp_fill_gaps USING BTREE (id);
ANALYZE tmp_fill_gaps;

-- insert filled gaps into original conflated matched ;
INSERT INTO {schema}.{table}
SELECT
    tmp_fill_gaps.id,
    target.{target_geom},
    tmp_fill_gaps.source_id,
    tmp_fill_gaps.attr AS {source_column},
    NULL
FROM
    tmp_fill_gaps,
    {target_schema}.{target_table} target
WHERE target.{target_pkid} = tmp_fill_gaps.id
;