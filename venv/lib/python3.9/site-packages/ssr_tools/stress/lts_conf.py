###################################################################
# The Config class houses methods for dealing with the config file
###################################################################
"""
WE CAN COPY/PASTE THIS INTO SSRC_TOOLS WHERE THE STRESS TOOL WILL LIVE 
"""

import os
from collections import Mapping
from psycopg2 import sql
from munch import Munch
from lts_dbutils import DBUtils

FORWARD_DIRECTION = "forward"
BACKWARD_DIRECTION = "backward"
 
class Conf(DBUtils):
    """pyBNAxx configuration class"""

    def __init__(self):
        DBUtils.__init__(self,"")
        self.segment_subs = None

    def parse_config(self,config):
        """
        Reads through the giant dictionary loaded from YAML and converts into
        munches that can be accessed with dot-notation

        Parameters
        ----------
        config : dict
            a dictionary of configuration options

        returns: 
        Munch
        """
        if isinstance(config, Mapping):
            for key, value in config.items():
                config[key] = self.parse_config(value)
            return Munch(config)
        return config

    def _build_segment_sql_substitutions(self,direction):
        """
        Builds commonly-shared segment-oriented SQL substitutions from the
        entries in the config file

        Parameters
        ----------
        direction : str
            the direction to generate substitutions for

        returns:
        a dictionary holding SQL objects
        """
        assumptions = self.config.stress.assumptions.segment
        settings = self.config.stress.segment[direction]

        # check required inputs
        if "lanes" not in settings and "lanes" not in assumptions:
            raise ValueError("Lane data is required as either an attribute or an assumption")
        if "speed" not in settings and "speed" not in assumptions:
            raise ValueError("Speed data is required as either an attribute or an assumption")
        if "aadt" not in settings and "aadt" not in assumptions:
            raise ValueError("AADT data is required as either an attribute or an assumption")

        # lanes
        if "lanes" in settings:
            lanes = sql.Identifier(settings["lanes"])
        else:
            lanes = sql.SQL("NULL")
        if "lanes" in assumptions:
            assumed_lanes = self._build_case(assumptions["lanes"])
        else:
            assumed_lanes = sql.SQL("NULL")

        # centerline
        if "centerline" in settings:
            centerline_column = sql.Identifier(settings["centerline"]["name"])
            centerline_value = sql.Literal(settings["centerline"]["val"])
        else:
            centerline_column = sql.SQL("NULL")
            centerline_value = sql.SQL("NULL")
        centerline = sql.SQL("({}={})").format(centerline_column,centerline_value)
        if "centerline" in assumptions:
            assumed_centerline = self._build_case(assumptions["centerline"])
        else:
            assumed_centerline = sql.SQL("FALSE")

        # low_parking
        if "low_parking" in settings:
            low_parking_column = sql.Identifier(settings["low_parking"]["name"])
            low_parking_value = sql.Literal(settings["low_parking"]["val"])
        else:
            low_parking_column = sql.SQL("NULL")
            low_parking_value = sql.SQL("NULL")
        low_parking = sql.SQL("({}={})").format(low_parking_column,low_parking_value)
        if "low_parking" in assumptions:
            assumed_low_parking = self._build_case(assumptions["low_parking"])
        else:
            assumed_low_parking = sql.SQL("FALSE")

        # speed
        if "speed" in settings:
            speed = sql.Identifier(settings["speed"])
        else:
            speed = sql.SQL("NULL")
        if "speed" in assumptions:
            assumed_speed = self._build_case(assumptions["speed"])
        else:
            assumed_speed = sql.SQL("NULL")
        
        # separation_type
        if "separation_type" in settings:
            separation_type_column = sql.Identifier(settings["separation_type"]["name"])
            separation_type_value = sql.Literal(settings["separation_type"]["val"])
        else:
            separation_type_column = sql.SQL("NULL")
            separation_type_value = sql.SQL("NULL")
        separation_type = sql.SQL("({}={})").format(separation_type_column,separation_type_value)
        if "separation_type" in assumptions:
            assumed_separation_type = self._build_case(assumptions["separation_type"])
        else:
            assumed_separation_type = sql.SQL("FALSE")

        # width
        if "width" in settings:
            width = sql.Identifier(settings["width"])
        else:
            width = sql.SQL("NULL")
        if "width" in assumptions:
            assumed_width = self._build_case(assumptions["width"])
        else:
            assumed_width = sql.SQL("NULL")

        # oneway
        if "oneway" in settings:
            oneway_column = sql.Identifier(settings["oneway"]["name"])
            oneway_value = sql.Literal(settings["oneway"]["val"])
            all_oneways = list()
            for d in [FORWARD_DIRECTION,BACKWARD_DIRECTION]:
                s = self.config.stress.segment[d]
                all_oneways.append(sql.Literal(s["oneway"]["val"]))
            all_oneway_values = sql.SQL(",").join(all_oneways)
        else:
            oneway_column = sql.Literal(0)
            oneway_value = sql.Literal(1)
            all_oneway_values = sql.Literal(1)
        twoway = sql.SQL("({} IS NULL OR {} NOT IN ({}))").format(
            oneway_column,
            oneway_column,
            all_oneway_values
        )
        oneway = sql.SQL("({}={})").format(oneway_column,oneway_value)

        # aadt
        if "aadt" in settings:
            aadt = sql.Identifier(settings["aadt"])
        else:
            aadt = sql.SQL("NULL")
        if "aadt" in assumptions:
            assumed_aadt = self._build_case(assumptions["aadt"])
        else:
            assumed_aadt = sql.SQL("NULL")

        # parking
        if "parking" in settings:
            parking_column = sql.Identifier(settings["parking"]["name"])
            parking_value = sql.Literal(settings["parking"]["val"])
        else:
            parking_column = sql.Literal(0)
            parking_value = sql.Literal(1)
        parking = sql.SQL("({}={})").format(parking_column,parking_value)
        if "parking" in assumptions:
            assumed_parking = self._build_case(assumptions["parking"])
        else:
            assumed_parking = sql.SQL("NULL")

        # parking_width
        if "parking_width" in settings:
            parking_width = sql.Identifier(settings["parking_width"])
        else:
            parking_width = sql.SQL("NULL")
        if "parking_width" in assumptions:
            assumed_parking_width = self._build_case(assumptions["parking_width"])
        else:
            assumed_parking_width = sql.SQL("NULL")

        # bike_lane_width
        if "bike_lane_width" in settings:
            bike_lane_width = sql.Identifier(settings["bike_lane_width"])
        else:
            bike_lane_width = sql.SQL("NULL")
        if "bike_lane_width" in assumptions:
            assumed_bike_lane_width = self._build_case(assumptions["bike_lane_width"])
        else:
            assumed_bike_lane_width = sql.SQL("NULL")

        # shared
        shared = sql.SQL("{c} IS NULL OR {c} NOT IN ({l},{bl},{t},{p})").format(
            c=sql.Identifier(settings["bike_infra"]["name"]),
            l=sql.Literal(settings["bike_infra"]["lane"]),
            bl=sql.Literal(settings["bike_infra"]["buffered_lane"]),
            t=sql.Literal(settings["bike_infra"]["track"]),
            p=sql.Literal(settings["bike_infra"]["path"])
        )

        # bike_lane
        bike_lane = sql.SQL("({} IN ({},{}))").format(
            sql.Identifier(settings["bike_infra"]["name"]),
            sql.Literal(settings["bike_infra"]["lane"]),
            sql.Literal(settings["bike_infra"]["buffered_lane"])
        )

        # track
        track = sql.SQL("({}={})").format(
            sql.Identifier(settings["bike_infra"]["name"]),
            sql.Literal(settings["bike_infra"]["track"])
        )

        # path
        path = sql.SQL("({}={})").format(
            sql.Identifier(settings["bike_infra"]["name"]),
            sql.Literal(settings["bike_infra"]["path"])
        )

        # other vals
        schema, table = self.parse_table_name(self.config.bna.network.roads.table)
        if schema is None:
            schema = self.get_schema(table)
        if "uid" in self.config.bna.network.roads:
            id_column = self.config.bna.network.roads.uid
        else:
            id_column = self.get_pkid_col(table,schema)
        
        if "fclass" in self.config.bna.network.roads:
            fclass_column = self.config.bna.network.roads.fclass
        else:
            raise ValueError("Functional Classification data is required")

        if "geom" in self.config.bna.network.roads:
            geom = self.config.bna.network.roads.geom
        else:
            geom = self._get_geom_column(table,schema)
        shared_lts_schema, shared_lts_table = self.parse_table_name(self.config.stress.lookup_tables.shared)
        if shared_lts_schema is None:
            shared_lts_schema = self.get_schema(shared_lts_table)
        bike_lane_lts_schema, bike_lane_lts_table = self.parse_table_name(self.config.stress.lookup_tables.bike_lane)
        if bike_lane_lts_schema is None:
            bike_lane_lts_schema = self.get_schema(bike_lane_lts_table)
        track_lts_schema, track_lts_table = self.parse_table_name(self.config.stress.lookup_tables.track)
        if track_lts_schema is None:
            track_lts_schema = self.get_schema(track_lts_table)

        # set up substitutions
        subs = {
            "id_column": sql.Identifier(id_column),
            "segment_stress_forward": sql.Identifier(self.config.bna.network.roads.stress.segment.forward),
            "segment_stress_backward": sql.Identifier(self.config.bna.network.roads.stress.segment.backward),
            "lanes": lanes,
            "assumed_lanes": assumed_lanes,
            "centerline": centerline,
            "assumed_centerline": assumed_centerline,
            "low_parking": low_parking,
            "assumed_low_parking": assumed_low_parking,
            "speed": speed,
            "assumed_speed": assumed_speed,
            "width": width,
            "assumed_width": assumed_width,
            "aadt": aadt,
            "assumed_aadt": assumed_aadt,
            "separation_type": separation_type,
            "assumed_separation_type": assumed_separation_type,
            "parking": parking,
            "assumed_parking": assumed_parking,
            "parking_width": parking_width,
            "assumed_parking_width": assumed_parking_width,
            "bike_lane_width": bike_lane_width,
            "assumed_bike_lane_width": assumed_bike_lane_width,
            "in_schema": sql.Identifier(schema),
            "in_table": sql.Identifier(table),
            "geom": sql.Identifier(geom),
            "oneway": oneway,
            "twoway": twoway,
            "shared": shared,
            "bike_lane": bike_lane,
            "track": track,
            "path": path,
            "shared_lts_schema": sql.Identifier(shared_lts_schema),
            "shared_lts_table": sql.Identifier(shared_lts_table),
            "bike_lane_lts_schema": sql.Identifier(bike_lane_lts_schema),
            "bike_lane_lts_table": sql.Identifier(bike_lane_lts_table),
            "track_lts_schema": sql.Identifier(track_lts_schema),
            "track_lts_table": sql.Identifier(track_lts_table)
        }

        return subs


    def _build_crossing_sql_substitutions(self,direction):
        """
        Builds crossing SQL substitutions from the entries in the config
        file

        Parameters
        ----------
        direction : str
            the direction to generate substitutions for

        returns:
        a dictionary holding SQL objects
        """
        assumptions = self.config.stress.assumptions.crossing
        if self.config.stress.crossing[direction] is None:
            settings = dict()
        else:
            settings = self.config.stress.crossing[direction]

        # check required inputs
        if "intersection_tolerance" not in self.config.stress.crossing:
            raise ValueError("Intersection tolerance not specified in config")
        if "control" not in self.config.stress.crossing:
            raise ValueError("Control data not specified in config")

        intersection_tolerance = self.config.stress.crossing.intersection_tolerance

        # stress table
        schema, table = self.parse_table_name(self.config.bna.network.roads.table)
        if schema is None:
            schema = self.get_schema(table)
        if "uid" in self.config.bna.network.roads:
            id_column = self.config.bna.network.roads.uid
        else:
            id_column = self.get_pkid_col(table,schema)
        if "geom" in self.config.bna.network.roads:
            geom = self.config.bna.network.roads.geom
        else:
            geom = self._get_geom_column(table,schema)

        # control
        control_schema, control_table = self.parse_table_name(self.config.stress.crossing.control.table)
        if control_schema is None:
            control_schema = self.get_schema(control_table)
        if "geom" in self.config.stress.crossing.control:
            control_geom = self.config.stress.crossing.control.geom
        else:
            control_geom = self._get_geom_column(control_table,control_schema)
        control_column = self.config.stress.crossing.control.column.name
        four_way_stop = self.config.stress.crossing.control.column.four_way_stop
        signal = self.config.stress.crossing.control.column.signal
        rrfb = self.config.stress.crossing.control.column.rrfb
        hawk = self.config.stress.crossing.control.column.hawk
        bike_signal = self.config.stress.crossing.control.column.bike_signal

        # island
        island_schema, island_table = self.parse_table_name(self.config.stress.crossing.island.table)
        if island_schema is None:
            island_schema = self.get_schema(island_table)
        if "geom" in self.config.stress.crossing.island:
            island_geom = self.config.stress.crossing.island.geom
        else:
            island_geom = self._get_geom_column(island_table,island_schema)
        island_column = self.config.stress.crossing.island.column.name

        # directional_attribute_aggregation
        data_insert = self.read_sql_from_file(
            os.path.join(
                self.module_dir,
                "sql",
                "stress",
                "crossing",
                "directional_attributes.sql"
            )
        )
        directional_attributes = self.read_sql_from_file(
            os.path.join(
                self.module_dir,
                "sql",
                "stress",
                "crossing",
                "directional_attributes_table.sql"
            )
        )
        data_insert_query = sql.SQL("")
        for d in [FORWARD_DIRECTION,BACKWARD_DIRECTION]:
            data_insert_query += sql.SQL(data_insert).format(**self.segment_subs[d])
        data_insert_subs = self.segment_subs["forward"].copy()
        data_insert_subs["data_insert"] = data_insert_query
        directional_attribute_aggregation = sql.SQL(directional_attributes).format(**data_insert_subs)

        #
        # grab direct settings (if any are specified)
        #

        # lanes
        if "lanes" in settings:
            cross_lanes = sql.SQL("actual.") + sql.Identifier(settings["lanes"])
        else:
            cross_lanes = sql.SQL("NULL")

        # speed
        if "speed" in settings:
            cross_speed = sql.SQL("actual.") + sql.Identifier(settings["speed"])
        else:
            cross_speed = sql.SQL("NULL")

        # control
        if "control" in settings:
            cross_control = sql.SQL("actual.") + sql.Identifier(settings["control"])
        else:
            cross_control = sql.SQL("NULL")
        
        # aadt
        if "aadt" in settings:
            cross_aadt = sql.SQL("actual.") + sql.Identifier(settings["aadt"])
        else:
            cross_aadt = sql.SQL("NULL")

        # island
        if "island" in settings:
            cross_island = sql.SQL("actual.") + sql.Identifier(settings["island"])
        else:
            cross_island = sql.SQL("NULL")
        
        # oneway
        if "oneway" in settings:
            oneway_column = sql.Identifier(settings["oneway"]["name"])
            oneway_value = sql.Literal(settings["oneway"]["val"])
        else:
            oneway_column = sql.SQL("NULL")
            oneway_value = sql.SQL("NULL")
        cross_oneway = sql.SQL("({}={})").format(oneway_column,oneway_value)
        if "oneway" in assumptions:
            assumed_cross_oneway= self._build_case(assumptions["oneway"])
        else:
            assumed_cross_oneway = sql.SQL("FALSE")

        # misc
        cross_lts_schema, cross_lts_table = self.parse_table_name(self.config.stress.lookup_tables.crossing)
        if cross_lts_schema is None:
            cross_lts_schema = self.get_schema(cross_lts_table)

        subs = {
            "directional_attribute_aggregation": directional_attribute_aggregation,
            "intersection_tolerance": sql.Literal(intersection_tolerance),
            "point": sql.Identifier("_".join([direction,"pt"])),
            "in_schema": sql.Identifier(schema),
            "in_table": sql.Identifier(table),
            "geom": sql.Identifier(geom),
            "id_column": sql.Identifier(id_column),
            "cross_stress_forward": sql.Identifier(self.config.bna.network.roads.stress.crossing.forward),
            "cross_stress_backward": sql.Identifier(self.config.bna.network.roads.stress.crossing.backward),
            "control_schema": sql.Identifier(control_schema),
            "control_table": sql.Identifier(control_table),
            "control_geom": sql.Identifier(control_geom),
            "control_column": sql.Identifier(control_column),
            "four_way_stop": sql.Literal(four_way_stop),
            "signal": sql.Literal(signal),
            "bike_signal": sql.Literal(bike_signal),
            "rrfb": sql.Literal(rrfb),
            "hawk": sql.Literal(hawk),
            "island_schema": sql.Identifier(island_schema),
            "island_table": sql.Identifier(island_table),
            "island_geom": sql.Identifier(island_geom),
            "island_column": sql.Identifier(island_column),
            "cross_lanes": cross_lanes,
            "cross_speed": cross_speed,
            "cross_aadt": cross_aadt,
            "cross_control": cross_control,
            "cross_island": cross_island,
            "cross_oneway": cross_oneway,
            "cross_lts_schema": sql.Identifier(cross_lts_schema),
            "cross_lts_table": sql.Identifier(cross_lts_table)
        }

        # control_assignment
        raw = self.read_sql_from_file(
            os.path.join(
                self.module_dir,
                "sql",
                "stress",
                "crossing",
                "control_assignment.sql"
            )
        )
        control_assignment = sql.SQL(raw).format(**subs)
        subs["control_assignment"] = control_assignment

        # island_assignment
        raw = self.read_sql_from_file(
            os.path.join(
                self.module_dir,
                "sql",
                "stress",
                "crossing",
                "island_assignment.sql"
            )
        )
        island_assignment = sql.SQL(raw).format(**subs)
        subs["island_assignment"] = island_assignment

        # priority_assignment
        raw = self.read_sql_from_file(
            os.path.join(
                self.module_dir,
                "sql",
                "stress",
                "crossing",
                "priority_assignment.sql"
            )
        )
        priority_assignment = sql.SQL("")
        if "priority" in assumptions:
            for i, w in enumerate(assumptions["priority"]):
                s = subs.copy()
                this_priority_table = "tmp_this_priority_" + str(i)
                this_where_test = w["where"]
                if this_where_test == "*":
                    this_where_test = "TRUE"
                that_priority_table = "tmp_that_priority_" + str(i)
                that_where_test = w["meets"]
                if that_where_test == "*":
                    that_where_test = "TRUE"
                priority_table = "tmp_priority_" + str(i)

                s["this_priority_table"] = sql.Identifier(this_priority_table)
                s["this_where_test"] = sql.SQL(this_where_test)
                s["that_priority_table"] = sql.Identifier(that_priority_table)
                s["that_where_test"] = sql.SQL(that_where_test)
                s["priority_table"] = sql.Identifier(priority_table)

                priority_assignment += sql.SQL(raw).format(**s)

        subs["priority_assignment"] = priority_assignment

        return subs

    def _build_ped_sql_substitutions(self):
        """
        Builds crossing SQL substitutions from the entries in the config
        file

        Parameters
        ----------

        returns:
        a dictionary holding SQL objects
        """
        assumptions = self.config.stress.assumptions.segment
        
        if self.config.stress.ped_crossing is None:
            settings = dict()
        else:
            settings = self.config.stress.ped_crossing
        
        # check required inputs
        if "crossing_tolerance" not in self.config.stress.ped_crossing:
            raise ValueError("crossing_tolerance tolerance not specified in config")
        if "control" not in self.config.stress.ped_crossing.params:
            raise ValueError("Control data not specified in config")
        
        crossing_tolerance = self.config.stress.ped_crossing.crossing_tolerance

        # seg stress table
        schema, table = self.parse_table_name(self.config.bna.network.ped_crossings.table)
        if schema is None:
            schema = self.get_schema(table)
        if "uid" in self.config.bna.network.ped_crossings:
            id_column = self.config.bna.network.ped_crossings.uid
        else:
            id_column = self.get_pkid_col(table,schema)
        if "geom" in self.config.bna.network.ped_crossings:
            geom = self.config.bna.network.ped_crossings.geom
        else:
            geom = self._get_geom_column(table,schema)

        # control
        control_column = self.config.stress.ped_crossing.params.control.name
        four_way_stop = self.config.stress.ped_crossing.params.control.four_way_stop
        signal = self.config.stress.ped_crossing.params.control.signal
        rrfb = self.config.stress.ped_crossing.params.control.rrfb
        hawk = self.config.stress.ped_crossing.params.control.hawk

        # island
        island_column = self.config.stress.ped_crossing.params.island

        # lanes
        if "lanes" in settings:
            cross_lanes = sql.SQL("actual.") + sql.Identifier(settings["lanes"])
        else:
            cross_lanes = sql.SQL("NULL")

        # speed
        if "speed" in settings:
            cross_speed = sql.SQL("actual.") + sql.Identifier(settings["speed"])
        else:
            cross_speed = sql.SQL("NULL")

        # aadt
        if "aadt" in settings:
            cross_aadt = sql.SQL("actual.") + sql.Identifier(settings["aadt"])
        else:
            cross_aadt= sql.SQL("NULL")

        # control
        if "control" in settings:
            cross_control = sql.SQL("actual.") + sql.Identifier(settings["control"])
        else:
            cross_control = sql.SQL("NULL")

        # island
        if "island" in settings:
            cross_island = sql.SQL("actual.") + sql.Identifier(settings["island"])
        else:
            cross_island = sql.SQL("NULL")
        
         # oneway
        if "oneway" in settings:
            oneway_column = sql.Identifier(settings["oneway"]["name"])
            oneway_value = sql.Literal(settings["oneway"]["val"])
        else:
            oneway_column = sql.SQL("NULL")
            oneway_value = sql.SQL("NULL")
        cross_oneway = sql.SQL("({}={})").format(oneway_column,oneway_value)
        if "oneway" in assumptions:
            assumed_cross_oneway= self._build_case(assumptions["oneway"])
        else:
            assumed_cross_oneway = sql.SQL("FALSE")
        
        
        # misc
        cross_lts_schema, cross_lts_table = self.parse_table_name(self.config.stress.lookup_tables.crossing)
        if cross_lts_schema is None:
            cross_lts_schema = self.get_schema(cross_lts_table)

        subs = {
            "geom": sql.Identifier(geom),
            "id_column": sql.Identifier(id_column),
            "in_schema": sql.Identifier(schema),
            "in_table": sql.Identifier(table),
            "control_column": sql.Identifier(control_column),
            "four_way_stop": sql.Literal(four_way_stop),
            "signal": sql.Literal(signal),
            "rrfb": sql.Literal(rrfb),
            "hawk": sql.Literal(hawk),
            "island_column": sql.Identifier(island_column),
            "cross_lanes": cross_lanes,
            "cross_speed": cross_speed,
            "cross_aadt": cross_aadt,
            "cross_control": cross_control,
            "cross_island": cross_island,
            "cross_oneway": cross_oneway,
            "cross_lts_schema": sql.Identifier(cross_lts_schema),
            "cross_lts_table": sql.Identifier(cross_lts_table)
        }

        return subs

    def _build_case(self,vals,prefix=None):
        if prefix is None:
            prefix = sql.SQL("")
        else:
            prefix = sql.SQL(prefix + ".")
        case = sql.SQL(" CASE ")
        for val in vals:
            if "else" in val:
                pass
            elif "where" in val:
                if val["where"] == "*":
                    case += sql.SQL(" WHEN TRUE THEN ") + sql.Literal(val["val"])
                else:
                    case += sql.SQL(" WHEN ") + prefix + sql.SQL(val["where"]) + sql.SQL(" THEN ") + sql.Literal(val["val"])
            else:
                raise
        if "else" in vals[-1]:
            case += sql.SQL(" ELSE ") + sql.Literal(vals[-1]["else"])
        case += sql.SQL(" END ")
        return case

