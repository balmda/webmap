

DROP TABLE IF EXISTS scratch.tmp_alldirs;
CREATE TABLE scratch.tmp_alldirs (
    id INTEGER,
    lanes INTEGER,
    speed INTEGER
); 

-- two way
INSERT INTO scratch.tmp_alldirs
SELECT
    p_key AS id,
    COALESCE(ft_lanes,0) + COALESCE(tf_lanes,0),
    COALESCE(speed_limit,25)::INTEGER
FROM
    automated.segments
WHERE oneway NOT IN ('T', 'F') OR oneway IS NULL
;
-- one way
INSERT INTO scratch.tmp_alldirs
SELECT
    p_key AS id,
    COALESCE(ft_lanes,0) + COALESCE(tf_lanes,0),
    COALESCE(speed_limit,25)::INTEGER
FROM
    automated.segments
WHERE oneway IN ('T', 'F') 
;

ALTER TABLE scratch.tmp_alldirs ADD COLUMN pkey SERIAL PRIMARY KEY; 
CREATE INDEX tidx_tmp_attrs_pkey ON scratch.tmp_alldirs (pkey); ANALYZE scratch.tmp_alldirs;
CREATE INDEX IF NOT EXISTS idx_tmp_attrs_pkey
ON scratch.tmp_alldirs
USING BTREE (pkey);
ANALYZE scratch.tmp_alldirs;


DROP TABLE IF EXISTS scratch.tmp_combineddirs;
SELECT DISTINCT ON (b.id)
    b.id,
    o.geom AS geom,
    bna_MultiEndPoint(o.geom) AS forward_pt,
    ST_MakeLine(ST_PointN(o.geom,-2),ST_EndPoint(o.geom)) AS forward_ln,
    bna_MultiStartPoint(o.geom) AS backward_pt,
    ST_MakeLine(ST_PointN(o.geom,2),ST_StartPoint(o.geom)) AS backward_ln,
    SUM(b.lanes) AS lanes,
    MAX(b.speed) AS speed
INTO scratch.tmp_combineddirs
FROM
    scratch.tmp_alldirs b,
    automated.segments o
WHERE
    b.id = o.p_key
GROUP BY
    b.id,
    o.geom
ORDER BY
    b.id
;

CREATE INDEX tidx_tmp_combineddirs_id ON scratch.tmp_alldirs (id);
CREATE INDEX sidx_tmp_combineddirs ON scratch.tmp_combineddirs USING GIST (geom);
CREATE INDEX sidx_tmp_combineddirs_fwd ON scratch.tmp_combineddirs USING GIST (forward_pt);
CREATE INDEX sidx_tmp_combineddirs_bwd ON scratch.tmp_combineddirs USING GIST (backward_pt);
ANALYZE scratch.tmp_combineddirs;

-- by direction (looped in python)
DROP TABLE IF EXISTS scratch.tmp_intcount;
SELECT
    this.geom, 
    this.id,
    COUNT(that.id) AS legs
INTO TABLE scratch.tmp_intcount
FROM
    scratch.tmp_combineddirs this,
    scratch.tmp_combineddirs that
WHERE
    ST_DWithin(this.geom,that.geom,10)
    AND (
        ST_DWithin(this.forward_pt,that.forward_pt,10)
        OR ST_DWithin(this.forward_pt,that.backward_pt,10)
    )
GROUP BY this.id, this.geom
;

DROP TABLE IF EXISTS scratch.tmp_allconnections;
CREATE TABLE scratch.tmp_allconnections AS (
    -- forward
    SELECT
        this.forward_ln ,
        this.id AS this_id,
        that.id AS that_id,
        bna_CompareAzimuths(this.forward_ln,that.forward_ln) AS angle
    FROM
        scratch.tmp_combineddirs this,
        scratch.tmp_combineddirs that
    WHERE
        this.id != that.id
        AND ST_DWithin(this.forward_pt,that.forward_pt,10)
    UNION ALL
    -- backward
    SELECT
        this.forward_ln,
        this.id AS this_id,
        that.id AS that_id,
        bna_CompareAzimuths(this.forward_ln,that.backward_ln) AS angle
    FROM
        scratch.tmp_combineddirs this,
        scratch.tmp_combineddirs that
    WHERE
        this.id != that.id
        AND ST_DWithin(this.forward_pt,that.backward_pt,10)
);

DROP TABLE IF EXISTS scratch.tmp_control;
SELECT DISTINCT ON (a.id)
    a.id,
    control.control_simple AS control
INTO TABLE scratch.tmp_control
FROM
    scratch.tmp_combineddirs a,
    automated.intersections AS control
WHERE
    ST_DWithin(a.forward_pt,control.geom,10)
ORDER BY
    a.id,
    ST_Distance(a.forward_pt,control.geom) ASC
;

-- #3rd called;
DROP TABLE IF EXISTS scratch.tmp_island;
SELECT DISTINCT ON (a.id)
    a.id,
    island.island AS island
INTO TABLE scratch.tmp_island
FROM
    scratch.tmp_combineddirs a,
    automated.intersections AS island
WHERE
    ST_DWithin(a.forward_pt,island.geom,10)
ORDER BY
    a.id,
    ST_Distance(a.forward_pt,island.geom) ASC
;



DROP TABLE IF EXISTS scratch.tmp_cross_streets_assumed;
SELECT
    this.this_id AS id,
    control.control,
    MAX(that.lanes) AS lanes,
    MAX(that.speed) AS speed,
    island.island
INTO TABLE scratch.tmp_cross_streets_assumed
FROM
    scratch.tmp_allconnections this,
    scratch.tmp_intcount a,
    scratch.tmp_combineddirs that,
    scratch.tmp_control control,
    scratch.tmp_island island
WHERE
    this.angle > 20
    AND this.this_id = a.id
    AND this.that_id = that.id
    AND this.this_id = control.id
    AND this.that_id = island.id
GROUP BY
    this.this_id,
    control.control,
    island.island
;


DROP TABLE IF EXISTS scratch.tmp_cross_streets;
SELECT
    actual.p_key AS id,
    COALESCE(NULL,assumed.control) AS control,
    COALESCE(COALESCE(actual.ft_lanes,0) + COALESCE(actual.tf_lanes,0),assumed.lanes) AS lanes,
    COALESCE(COALESCE(actual.speed_limit,25),assumed.speed) AS speed,
    COALESCE(NULL,assumed.island) AS island
INTO TABLE scratch.tmp_cross_streets
FROM
    automated.segments actual,
    scratch.tmp_cross_streets_assumed assumed
WHERE
    actual.p_key= assumed.id
;

-----------
-- 02_crossing.sql 
DROP TABLE IF EXISTS scratch.tmp_stress;
SELECT DISTINCT ON (attrs.id)
    attrs.id,
    attrs.control,
    attrs.lanes,
    attrs.speed,
    attrs.island,
    lts.stress
INTO TABLE scratch.tmp_stress
FROM
    scratch.tmp_cross_streets AS attrs,
    generated.stress_crossing lts
WHERE
    COALESCE(attrs.control,'none') = COALESCE(lts.control,'none')
    AND attrs.lanes <= lts.lanes
    AND attrs.speed <= lts.speed
    AND COALESCE(attrs.island,FALSE) = COALESCE(lts.island,FALSE)
ORDER BY
    attrs.id,
    lts.stress ASC
;

DROP TABLE IF EXISTS scratch.test_crossing ;
CREATE TABLE scratch.test_crossing AS (
    SELECT
        p_key,
        geom,
        NULL::INTEGER AS legs,
        NULL::BOOLEAN AS priority,
        NULL::TEXT AS control,
        NULL::INTEGER AS lanes,
        NULL::BOOLEAN AS oneway, 
        NULL::INTEGER AS speed,
        NULL::INTEGER AS aadt,
        NULL::BOOLEAN AS island,
        NULL::INTEGER AS stress, 
        NULL::TEXT AS criteria,
        NULL::TEXT AS condition
    FROM automated.segments
);


INSERT INTO scratch.test_crossing(
    p_key,
    geom,
    legs,
    control,
    lanes,
    speed,
    island,
    stress
)
SELECT
    tmp_stress.id,
    b.geom,
    tmp_intcount.legs,
    tmp_stress.control,
    tmp_stress.lanes,
    tmp_stress.speed,
    tmp_stress.island,
    CASE WHEN tmp_intcount.legs = 2 THEN 1 ELSE tmp_stress.stress END
FROM
    automated.segments b
    LEFT JOIN scratch.tmp_stress AS tmp_stress
        ON tmp_stress.id = b.p_key
    LEFT JOIN scratch.tmp_intcount AS tmp_intcount
        ON tmp_intcount.id = b.p_key
;


