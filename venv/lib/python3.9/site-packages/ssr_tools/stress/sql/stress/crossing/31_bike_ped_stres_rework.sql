-- this makes the crossing nodes and segments
CREATE TABLE {out_schema}.{out_table} AS (
    SELECT 
        ints.{int_id_column} AS int_id,
        segs.{seg_id_column} AS seg_id,
        ints.{legs},
        (ST_Dump(
            ST_Intersection(
                ST_Boundary(
                    ST_Buffer(ints.{int_geom},{crosswalk_tolerance})),segs.{seg_geom}))).geom AS approach_pt, -- for ped stress
        NULL::GEOMETRY(LineString, {srid}) AS approach_ln, -- for bike stress
        ints.{control_simple} AS int_control, 
        CASE 
            WHEN ints.{control_simple} = 'Traffic Signal' THEN 'signal'
            WHEN ints.{control_simple} = 'All-Way Stop Sign' THEN 'four way stop'
            ELSE NULL END AS approach_control,
        segs.{st_name} AS along_name,
        NULL::TEXT AS cross_name,
        segs.{fclass} AS along_fclass, 
        NULL::TEXT AS cross_fclass,
        segs.{oneway_bool} AS along_oneway,
        FALSE::BOOLEAN AS cross_oneway,
        segs.{aadt} AS along_aadt,
        NULL::INT AS cross_aadt,
        segs.{tot_lanes} AS along_num_lanes,
        NULL::INT AS cross_num_lanes,
        segs.{speed_limit} AS along_speed_limit,
        NULL::INT AS cross_speed_limit,
        segs.{island}  AS along_crossing_island,
        FALSE::BOOLEAN AS cross_crossing_island,

        NULL::INT AS bike_crossing_stress, 
        -- segs.{seg_stress_max} AS bike_seg_stress, --TODO add max function to stress.py and conf.py
        NULL::INT AS bike_stress, 
        NULL::TEXT AS bike_condition, 
        NULL::TEXT AS bike_criteria, 
        NULL::INT AS ped_stress, 
        NULL::TEXT AS ped_condition, 
        NULL::TEXT AS ped_criteria
FROM 
    {int_schema}.{int_table} ints, 
    {seg_schema}.{in_table} segs
WHERE ST_Intersects(ST_Buffer(ints.{int_geom},40), segs.{seg_geom})
AND {filter}
);

ALTER TABLE {out_schema}.{out_table} ADD COLUMN p_key SERIAL PRIMARY KEY; 

CREATE INDEX IF NOT EXISTS idx_bike_ped_crossing_stress_p_key
ON {out_schema}.{out_table} 
USING BTREE (p_key);

CREATE INDEX IF NOT EXISTS gist_bike_ped_crossing_stress_approach_pt
ON {out_schema}.{out_table} 
USING GIST (approach_pt);

ANALYZE {out_schema}.{out_table};

UPDATE {out_schema}.{out_table}  a
SET approach_ln = ST_MakeLine(a.approach_pt,b.{int_geom})
FROM {int_schema}.{int_table} b
WHERE ST_DWithin(a.approach_pt, b.{int_geom}, 40)
AND a.int_id = b.p_key
;

CREATE INDEX IF NOT EXISTS gist_bike_ped_crossing_stress_approach_ln
ON {out_schema}.{out_table} 
USING GIST (approach_ln);


DROP TABLE IF EXISTS scratch.approach_all;
CREATE TABLE scratch.approach_all AS (
    SELECT
        this.approach_ln, 
        this.legs,
        this.p_key AS this_id,
        that.p_key AS that_id,
        bna_CompareAzimuths(this.approach_ln,that.approach_ln) AS angle, 
        that.approach_control AS that_approach_control,
        that.along_name AS that_along_name,
        that.along_fclass AS that_along_fclass, 
        that.along_oneway AS that_along_oneway,
        that.along_aadt AS that_along_aadt,
        that.along_num_lanes AS that_along_num_lanes,
        that.along_speed_limit AS that_along_speed_limit, 
        that.along_crossing_island AS that_along_crossing_island
    FROM
        {out_schema}.{out_table}  this,
        {out_schema}.{out_table}  that
    WHERE this.p_key != that.p_key
    AND ST_DWithin(this.approach_ln, that.approach_ln, 100)
    AND this.int_id = that.int_id
);
 

ALTER TABLE scratch.approach_all ADD COLUMN p_key SERIAL PRIMARY KEY; 

CREATE INDEX IF NOT EXISTS idx_scratch_bike_approach_all_p_key
ON scratch.approach_all
USING BTREE (p_key);

ANALYZE scratch.approach_all;



UPDATE {out_schema}.{out_table}  a 
SET cross_num_lanes = x.cross_num_lanes,
    cross_aadt = x.cross_aadt,
    cross_speed_limit = x.cross_speed_limit, 
    cross_oneway = x.cross_oneway,
    cross_crossing_island = x.cross_crossing_island, 
    cross_name = x.cross_name, 
    cross_fclass = x.cross_fclass
FROM (
    SELECT 
        this.p_key, 
        MAX(that.that_along_num_lanes) AS cross_num_lanes, 
        MAX(that.that_along_aadt) AS cross_aadt, 
        MAX(that.that_along_speed_limit) AS cross_speed_limit, 
        CASE 
            WHEN SUM(that.that_along_oneway::INT) > 0 THEN TRUE 
            ELSE FALSE 
            END AS cross_oneway, 
        CASE 
            WHEN SUM(that.that_along_crossing_island::INT) > 0 THEN TRUE 
            ELSE FALSE 
            END AS cross_crossing_island, 
        String_agg(DISTINCT that.that_along_name,', ') AS cross_name, 
        String_agg(DISTINCT that.that_along_fclass,', ') AS cross_fclass
    FROM 
        {out_schema}.{out_table}  this,
        scratch.approach_all that
    WHERE this.p_key = that.this_id
    AND that.angle > 20
    GROUP BY this.p_key
    ) x 
WHERE x.p_key = a.p_key
;



-- #comparing against LTS tables;
UPDATE {out_schema}.{out_table}  attrs
SET (bike_crossing_stress, 
    bike_criteria,
    bike_condition 
    )=(
    SELECT 
        lts.stress, 
        lts.criteria, 
        lts.condition
    FROM generated.stress_crossing_ssrc_v1 lts
    WHERE attrs.cross_num_lanes <= lts.lanes
    AND attrs.cross_oneway = lts.oneway
    AND COALESCE(attrs.approach_control, 'NA') = COALESCE(lts.control, 'NA')
    AND attrs.cross_crossing_island = lts.island
    AND attrs.cross_speed_limit <= lts.speed
    AND COALESCE(attrs.cross_aadt,500) <= lts.aadt
    ORDER BY
        attrs.p_key,
        (attrs.cross_num_lanes = lts.lanes) DESC, --ensures that we give priority to an exact match
        (attrs.cross_speed_limit = lts.speed) DESC, --ensures that we give priority to an exact match
        lts.stress ASC
    LIMIT 1 
);

SELECT *
FROM generated.stress_crossing_ssrc_v1
WHERE control IS NULL
AND lanes = 4 
AND NOT island 
AND NOT oneway
ORDER BY aadt, speed, lanes
;




-- #comparing against LTS tables;
UPDATE {out_schema}.{out_table}  attrs
SET (ped_stress, 
    ped_criteria,
    ped_condition 
    )=(
    SELECT 
        lts.stress, 
        lts.criteria, 
        lts.condition
    FROM generated.stress_crossing_ssrc_v1 lts
    WHERE attrs.along_num_lanes <= lts.lanes
    AND attrs.along_oneway = lts.oneway
    AND COALESCE(attrs.approach_control, 'NA') = COALESCE(lts.control, 'NA')
    AND attrs.along_crossing_island = lts.island
    AND attrs.along_speed_limit <= lts.speed
    AND COALESCE(attrs.along_aadt,500) <= lts.aadt
    ORDER BY
        attrs.p_key,
        (attrs.cross_num_lanes = lts.lanes) DESC, --ensures that we give priority to an exact match
        (attrs.cross_speed_limit = lts.speed) DESC, --ensures that we give priority to an exact match
        lts.stress ASC
    LIMIT 1 
);