-----------------------------------------------
-- bike lanes with all available data
-----------------------------------------------

-- #reading given and assumed road characteristics;
-- #1st called;
{directional_attribute_aggregation}

DROP TABLE IF EXISTS scratch.tmp_intcount;
SELECT
    this.id,
    COUNT(that.id) AS legs
INTO TABLE scratch.tmp_intcount
FROM
    scratch.tmp_combineddirs this,
    scratch.tmp_combineddirs that
WHERE
    ST_DWithin(this.geom,that.geom,{intersection_tolerance})
    AND (
        ST_DWithin(this.{point},that.forward_pt,{intersection_tolerance})
        OR ST_DWithin(this.{point},that.backward_pt,{intersection_tolerance})
    )
GROUP BY this.id
;

DROP TABLE IF EXISTS scratch.tmp_allconnections;
CREATE TABLE scratch.tmp_allconnections AS (
    -- forward
    SELECT
        this.id AS this_id,
        that.id AS that_id,
        bna_CompareAzimuths(this.{line},that.forward_ln) AS angle
    FROM
        scratch.tmp_combineddirs this,
        scratch.tmp_combineddirs that
    WHERE
        this.id != that.id
        AND ST_DWithin(this.{point},that.forward_pt,{intersection_tolerance})
    UNION ALL
    -- backward
    SELECT
        this.id AS this_id,
        that.id AS that_id,
        bna_CompareAzimuths(this.{line},that.backward_ln) AS angle
    FROM
        scratch.tmp_combineddirs this,
        scratch.tmp_combineddirs that
    WHERE
        this.id != that.id
        AND ST_DWithin(this.{point},that.backward_pt,{intersection_tolerance})
);

{control_assignment}

{island_assignment}

DROP TABLE IF EXISTS scratch.tmp_cross_streets_assumed;
SELECT
    this.this_id AS id,
    tmp_control.control,
    MAX(that.lanes) AS lanes,
    MAX(that.speed) AS speed,
    MAX(that.aadt) AS aadt,
    MAX(that.oneway::INT)::BOOLEAN AS oneway,
    tmp_island.island
INTO TABLE scratch.tmp_cross_streets_assumed
FROM
    scratch.tmp_allconnections this, -- table with all possible connections (all streets within x feet from backward_pt/forward_pt)
    scratch.tmp_intcount tmp_intcount, --count all pt near origin pt (i.e. num legs)
    scratch.tmp_combineddirs that, --all input segments (streets) 
    scratch.tmp_control tmp_control, 
    scratch.tmp_island tmp_island
WHERE
    this.angle > {angle}
    AND this.this_id = tmp_intcount.id
    AND this.that_id = that.id
    AND this.this_id = tmp_control.id
    AND this.that_id = tmp_island.id
GROUP BY
    this.this_id,
    tmp_control.control,
    tmp_island.island
;

DROP TABLE IF EXISTS scratch.tmp_cross_streets;
SELECT
    actual.{id_column} AS id,
    actual.geom AS geom,
    COALESCE({cross_control},assumed.control) AS control,
    COALESCE({cross_lanes},assumed.lanes) AS lanes,
    COALESCE({cross_speed},assumed.speed) AS speed,
    COALESCE({cross_aadt},assumed.aadt) AS aadt,
    COALESCE({cross_oneway},assumed.oneway) AS oneway,
    COALESCE({cross_island},assumed.island) AS island
INTO TABLE scratch.tmp_cross_streets
FROM
    {in_schema}.{in_table} actual,
    scratch.tmp_cross_streets_assumed assumed
WHERE
    actual.{id_column} = assumed.id
;
 