DROP TABLE IF EXISTS automated.crossing_stress;
CREATE TABLE automated.crossing_stress AS (
    SELECT 
        ints.p_key AS int_id,
        segs.p_key AS seg_id,
        ints.legs,
        (ST_Dump(
            ST_Intersection(
                ST_Boundary(
                    ST_Buffer(ints.geom,40)),segs.geom))).geom AS approach_pt, 
        NULL::GEOMETRY(LineString, 2229) AS approach_ln,
        ints.control_simple AS int_control, 
        CASE 
            WHEN ints.control_simple = 'Traffic Signal' THEN 'signal'
            WHEN ints.control_simple = 'All-Way Stop Sign' THEN 'four way stop'
            ELSE NULL END AS approach_control,
        segs.rd20full AS along_name,
        NULL::TEXT AS cross_name,
        segs.fclass AS along_fclass, 
        NULL::TEXT AS cross_fclass,
        segs.oneway_bool AS along_oneway,
        FALSE::BOOLEAN AS cross_oneway,
        segs.aadt AS along_aadt,
        NULL::INT AS cross_aadt,
        segs.tot_lanes AS along_num_lanes,
        NULL::INT AS cross_num_lanes,
        segs.speed_limit AS along_speed_limit,
        NULL::INT AS cross_speed_limit,
        FALSE::BOOLEAN AS along_crossing_island,
        FALSE::BOOLEAN AS cross_crossing_island,

        NULL::INT AS bike_crossing_stress, 
        segs.seg_stress_max AS bike_seg_stress, 
        NULL::INT AS bike_stress, 
        NULL::TEXT AS bike_condition, 
        NULL::TEXT AS bike_criteria, 
        NULL::INT AS ped_stress, 
        NULL::TEXT AS ped_condition, 
        NULL::TEXT AS ped_criteria
FROM 
    automated.intersections ints, 
    automated.segments segs
WHERE ST_Intersects(ST_Buffer(ints.geom,40), segs.geom)
AND ints.valid 
AND ints.valid_stress_int
);

ALTER TABLE automated.crossing_stress ADD COLUMN p_key SERIAL PRIMARY KEY; 

CREATE INDEX IF NOT EXISTS gist_automated_crossing_stress_approach_pt
ON automated.crossing_stress
USING GIST (approach_pt);

ANALYZE automated.crossing_stress;

UPDATE automated.crossing_stress a
SET approach_ln = ST_MakeLine(a.approach_pt,b.geom)
FROM automated.intersections b
WHERE ST_DWithin(a.approach_pt, b.geom, 40)
AND a.int_id = b.p_key
;

CREATE INDEX IF NOT EXISTS gist_automated_crossing_stress_approach_ln
ON automated.crossing_stress
USING GIST (approach_ln);

SELECT COUNT(*), seg_stress_max
FROM automated.segments 
WHERE fc_valid
GROUP BY seg_stress_max
;

DROP TABLE IF EXISTS scratch.bike_approach_all;
CREATE TABLE scratch.bike_approach_all AS (
    SELECT
        this.approach_ln, 
        this.legs,
        this.p_key AS this_id,
        that.p_key AS that_id,
        bna_CompareAzimuths(this.approach_ln,that.approach_ln) AS angle, 
        that.approach_control AS that_approach_control,
        that.along_name AS that_along_name,
        that.along_fclass AS that_along_fclass, 
        that.along_oneway AS that_along_oneway,
        that.along_aadt AS that_along_aadt,
        that.along_num_lanes AS that_along_num_lanes,
        that.along_speed_limit AS that_along_speed_limit, 
        that.along_crossing_island AS that_along_crossing_island
    FROM
        automated.crossing_stress this,
        automated.crossing_stress that
    WHERE this.p_key != that.p_key
    AND ST_DWithin(this.approach_ln,that.approach_ln, 100)
    AND this.int_id = that.int_id
);


ALTER TABLE scratch.bike_approach_all ADD COLUMN p_key SERIAL PRIMARY KEY; 

CREATE INDEX IF NOT EXISTS idx_scratch_bike_approach_all_p_key
ON scratch.bike_approach_all
USING BTREE (p_key);

ANALYZE scratch.bike_approach_all;



UPDATE automated.crossing_stress a 
SET cross_num_lanes = x.cross_num_lanes,
    cross_aadt = x.cross_aadt,
    cross_speed_limit = x.cross_speed_limit, 
    cross_oneway = x.cross_oneway,
    cross_crossing_island = x.cross_crossing_island, 
    cross_name = x.cross_name, 
    cross_fclass = x.cross_fclass
FROM (
    SELECT 
        this.p_key, 
        MAX(that.that_along_num_lanes) AS cross_num_lanes, 
        MAX(that.that_along_aadt) AS cross_aadt, 
        MAX(that.that_along_speed_limit) AS cross_speed_limit, 
        CASE 
            WHEN SUM(that.that_along_oneway::INT) > 0 THEN TRUE 
            ELSE FALSE 
            END AS cross_oneway, 
        CASE 
            WHEN SUM(that.that_along_crossing_island::INT) > 0 THEN TRUE 
            ELSE FALSE 
            END AS cross_crossing_island, 
        String_agg(DISTINCT that.that_along_name,', ') AS cross_name, 
        String_agg(DISTINCT that.that_along_fclass,', ') AS cross_fclass
    FROM 
        automated.crossing_stress this,
        scratch.bike_approach_all that
    WHERE this.p_key = that.this_id
    AND that.angle > 20
    GROUP BY this.p_key
    ) x 
WHERE x.p_key = a.p_key
;



-- #comparing against LTS tables;
UPDATE automated.crossing_stress attrs
SET (bike_crossing_stress, 
    bike_criteria,
    bike_condition 
    )=(
    SELECT 
        lts.stress, 
        lts.criteria, 
        lts.condition
    FROM generated.stress_crossing_ssrc_v1 lts
    WHERE attrs.cross_num_lanes <= lts.lanes
    AND attrs.cross_oneway = lts.oneway
    AND COALESCE(attrs.approach_control, 'NA') = COALESCE(lts.control, 'NA')
    AND attrs.cross_crossing_island = lts.island
    AND attrs.cross_speed_limit <= lts.speed
    AND COALESCE(attrs.cross_aadt,500) <= lts.aadt
    ORDER BY
        attrs.p_key,
        (attrs.cross_num_lanes = lts.lanes) DESC, --ensures that we give priority to an exact match
        (attrs.cross_speed_limit = lts.speed) DESC, --ensures that we give priority to an exact match
        lts.stress ASC
    LIMIT 1 
);

UPDATE automated.crossing_stress 
SET bike_stress = GREATEST(bike_crossing_stress, bike_seg_stress)
;


-- #comparing against LTS tables;
UPDATE automated.crossing_stress attrs
SET (ped_stress, 
    ped_criteria,
    ped_condition 
    )=(
    SELECT 
        lts.stress, 
        lts.criteria, 
        lts.condition
    FROM generated.stress_crossing_ssrc_v1 lts
    WHERE attrs.along_num_lanes <= lts.lanes
    AND attrs.along_oneway = lts.oneway
    AND COALESCE(attrs.approach_control, 'NA') = COALESCE(lts.control, 'NA')
    AND attrs.along_crossing_island = lts.island
    AND attrs.along_speed_limit <= lts.speed
    AND COALESCE(attrs.along_aadt,500) <= lts.aadt
    ORDER BY
        attrs.p_key,
        (attrs.cross_num_lanes = lts.lanes) DESC, --ensures that we give priority to an exact match
        (attrs.cross_speed_limit = lts.speed) DESC, --ensures that we give priority to an exact match
        lts.stress ASC
    LIMIT 1 
); 