import pandas as pd
import pandana
import numpy as np
from pandana.loaders import osm
import warnings
warnings.filterwarnings('ignore')
pd.options.display.float_format = '{:.2f}'.format
import osmnx as ox
import geopandas as gpd
import os
# from ..dbutils import DBUtils 
from ssr_tools.dbutils.dbutils import DBUtils
import psycopg2
from sqlalchemy import create_engine

class AccessNodes(DBUtils):
    def __init__(self, place_query, 
                host='ssrc-db1.c9lbv7c8ir6a.us-east-2.rds.amazonaws.com', db_name=None, 
                user='postgres', password='g.&whu1*Q(Ndsn,j', port='5432', verbose=True, outpath=None):
        
        self.verbose = verbose
        if self.verbose: print("Setting up AccessNode object")
        
        self.host = host
        self.db_name = db_name
        self.user = user 
        self.port = port
        self.password = password

        if db_name is None :
            raise ValueError("Need to have schema qualitified crash table") 

        DBUtils.__init__(self, host=host, db_name=db_name, user=user, password=password, port=port,
                         verbose=verbose, filename=__file__)
        self.place_query = place_query
        self.outpath = outpath
        #pre-checking OSMNX query requirements
        if isinstance(self.place_query, str):
            self.out_name = self.place_query .strip().replace(", ", "_").replace(" ", "_").lower()
        elif isinstance(self.place_query , dict):
            sep = '_'
            vals = self.place_query.values()
            self.out_name = sep.join(vals).lower()
            self.out_name = self.out_name .strip().replace(", ", "_").replace(" ", "_").lower()
        elif isinstance(self.place_query, list):
            raise TypeError('lists are fine for osmnx but not for this module. please provide one place at a time. You may iterate over a list of places if necessary')
        else:  # pragma: no cover
            raise TypeError("query must be dic or string")
    
    def build_network(self, source='osm', network='walk', osm_network_query=None, 
                    filter_bad_ints=False, buffer_size = 1000, 
                    other_nodes=None, other_nodes_geom = None, 
                    other_links=None, other_linkes_geom=None, other_links_from=None, other_links_to=None, other_links_length=None):
        print('lets build a link/node network')
        self.network = network
        self.osm_network_query = osm_network_query
        self.filter_bad_ints = filter_bad_ints
        self.buffer_size = buffer_size
        self.source = source
    
        if self.source == 'osm':
            if self.osm_network_query is None: 
                qstr = None
            elif self.osm_network_query == 'walk_basic':
                    qstr = '["highway"~"primary|primary_link|secondary|secondary_link|tertiary|tertiary_link|residential|path|living_street|pedestrian"]'
            elif self.osm_network_query is not None: 
                qstr = self.osm_network_query
            else:
                ValueError(f'preset is not in list of pre-defined network filters: {self.osm_network_query} or something else went wrong')
            print(f"pulling in ways and nodes for: {self.place_query}") 
            G = ox.graph_from_place(f"{self.place_query}", 
                            network_type=self.network, 
                            buffer_dist = self.buffer_size, 
                            retain_all=True, 
                            custom_filter = qstr)
            
            print('making network')
            G = ox.get_undirected(G)
            gdfs = ox.graph_to_gdfs(G)
            self.nodes, self.ways = gdfs
            self.nodes_osm = self.nodes.copy()
            if filter_bad_ints: 
                self.nodes_osm = self.nodes_osm[self.nodes_osm.street_count > 2]
            self.ways_osm = self.ways.copy()
            self.nodes['x'] = self.nodes.geometry.x
            self.nodes['y'] = self.nodes.geometry.y
            self.network = pandana.Network(self.nodes['x'], self.nodes['y'], 
                                    self.ways['from'], self.ways['to'], self.ways[['length']])
        elif self.source=='postgres':
            # read in nodes using chema qualified table name
            if self.verbose: print(f'Reading in {other_nodes} table from Postgres.')
            self.nodes_schema, self.nodes_name = self.parse_table_name(name=other_nodes)
            if self.nodes_schema is None :
                raise ValueError("Need to have schema qualitified nodes table")
            self.nodes = gpd.read_postgis(f"""SELECT * FROM {self.nodes_schema}.{self.nodes_name};""", self.create_db_con()[0])
            self.nodes['x'] = self.nodes[other_nodes_geom].x.astype(int)
            self.nodes['y'] = self.nodes[other_nodes_geom].y.astype(int)
            print(self.nodes.info(verbose=True))

            # read in links/ways using chema qualified table name
            if self.verbose: print(f'Reading in {other_links} table from Postgres.')
            self.ways_schema, self.ways_name = self.parse_table_name(name=other_links)
            if self.ways_schema is None :
                raise ValueError("Need to have schema qualitified link table")

            self.ways = gpd.read_postgis(f"""SELECT * FROM {self.ways_schema}.{self.ways_name};""", self.create_db_con()[0])
            if other_links_length is None: 
                self.ways['length'] = self.ways[other_linkes_geom].length.astype('long')
            else: 
                self.ways['length'] = self.ways[other_linkes_geom].astype('long')
            self.ways['from'] = self.ways[other_links_from].astype('long')
            self.ways['to'] = self.ways[other_links_to].astype('long')
            self.ways = self.ways[[other_linkes_geom,'from','to','length']]
            print(self.ways.info(verbose=True))
            if self.verbose: print('making network')
            self.network = pandana.Network(self.nodes['x'], self.nodes['y'], 
                                    self.ways['from'], self.ways['to'], self.ways[['length']])
        else:
            ValueError("okay...I don't have other input sources ready yet")        
    
    def run_proximity_analysis(self, amenity_types=None,network_distance=500, output_type='shp', out_schema=None):
        print('pulling in amenitiy data')
        self.amenity_types = amenity_types
        self.out_schema = out_schema
        minx, miny, maxx, maxy = self.nodes.total_bounds

        self.out_access = self.nodes_osm.copy()
        self.out_access.to_file(os.path.join(self.outpath,f"_{self.out_name}_pois_out.shp"))
        self.ways_osm.to_file(os.path.join(self.outpath,f"_{self.out_name}_ways.shp"))
        
        for cat, agg in self.amenity_types.items():
            self.cat = cat
            self.agg = agg
            print(f'working on {self.cat}')
            self.pois = osm.node_query(   
                            lat_min=miny, lng_min=minx,
                            lat_max=maxy, lng_max=maxx,
                            tags=f"'amenity'='{self.cat}'")
            print(f'{self.cat} has been pulled')
            self.pois_nodes = self.network.get_node_ids(self.pois.lon, self.pois.lat).values

            print('proximity analysis')
            self.network_distance = network_distance
            self.output_type = output_type
            self.network.set_pois(category = self.cat,
                            maxdist = self.buffer_size,
                            maxitems = 3,
                            x_col = self.pois.lon, 
                            y_col = self.pois.lat)

            results = self.network.nearest_pois(distance = self.buffer_size,
                                        category = self.cat,
                                        num_pois = 3,
                                        include_poi_ids = True)

            # access
            self.pois_nodes = self.network.get_node_ids(self.pois.lon, self.pois.lat)
            self.network.set(self.pois_nodes, name = self.cat)

            accessibility = self.network.aggregate(distance = self.network_distance,
                                            type = self.agg,
                                            name = self.cat)
        
            gdf_pois = gpd.GeoDataFrame(self.pois, geometry=gpd.points_from_xy(self.pois.lon, self.pois.lat), crs='epsg:4326')
            acess_df = pd.DataFrame(accessibility)
            acess_df.rename(columns={0:f'{self.cat}'},inplace=True)

            gdf_nodes = gpd.GeoDataFrame(self.nodes_osm, geometry='geometry', crs='epsg:4326')
            nodes_merged = gdf_nodes.merge(acess_df, how='left', left_index=True, right_index=True)
            # nodes_merged.rename(columns={0:'access'},inplace=True)

            self.out_access = self.out_access.merge(acess_df[f'{self.cat}'], how='left', left_index=True, right_index=True)
            # self.out_access = nodes_merged.merge(acess_df[f"{cat}"], how='left', left_index=True, right_index=True)
            
            print('exporting data')
            if self.output_type == 'shp':
                gdf_pois.to_file(os.path.join(self.outpath,f"{self.out_name}_pois_{self.cat}.{self.output_type}"))
                nodes_merged.to_file(os.path.join(self.outpath,f"{self.out_name}_pois_{self.cat}_access.{self.output_type}"))
                
            elif self.output_type == 'postgis':
                db = DBUtils(host=self.host, db_name = self.db_name, user=self.user, password=self.password, port=self.port)
                conn = psycopg2.connect(dbname=self.db_name, user=self.user, password=self.password, host=self.host, port=self.port)
                engine = create_engine(f'postgresql://{self.user}:{self.password}@{self.host}:{self.port}/{self.db_name}')
        
                db.df_to_postgres(df=gdf_pois, 
                                    temp_out_path=os.getcwd(), 
                                    table_name=f"{self.out_name}_pois_{self.cat}",
                                    table_schema= self.out_schema, 
                                    if_exists='replace',
                                    engine = engine, 
                                    conn= conn)
                db.df_to_postgres(df=nodes_merged, 
                                    temp_out_path = os.getcwd(), 
                                    table_name= f"{self.out_name}_pois_{self.cat}_access",
                                    table_schema=self.out_schema, 
                                    if_exists='replace',
                                    engine = engine, 
                                    conn= conn)
                cur = conn.cursor()
                cur.execute(f"ALTER TABLE {self.out_schema}.{self.out_name}_pois_{self.cat} ALTER COLUMN geometry TYPE Geometry(Point, 4326);")
                cur.execute(f"ALTER TABLE {self.out_schema}.{self.out_name}_pois_{self.cat} RENAME COLUMN geometry TO geom;")

                cur.execute(f"ALTER TABLE {self.out_schema}.{self.out_name}_pois_{self.cat}_access ALTER COLUMN geometry TYPE Geometry(Point, 4326);")
                cur.execute(f"ALTER TABLE {self.out_schema}.{self.out_name}_pois_{self.cat}_access RENAME COLUMN geometry TO geom;")
                conn.commit()
                
        print('wrapped up calcs.')
        if self.output_type == 'shp':
            self.out_access.to_file(os.path.join(self.outpath,f"{self.out_name}_acces_vals.{self.output_type}"))
        elif self.output_type == 'postgis':
            db.df_to_postgres(df = self.ways_osm, 
                                   temp_out_path= os.getcwd(),
                                    table_name= f"{self.out_name}_ways_osm",
                                    table_schema=self.out_schema, 
                                    if_exists='replace',
                                    engine = engine, 
                                    conn= conn)

            db.df_to_postgres(df = self.out_access, 
                                   temp_out_path= os.getcwd(),
                                    table_name= f"{self.out_name}_acces_vals",
                                    table_schema=self.out_schema, 
                                    if_exists='replace',
                                    engine = engine, 
                                    conn= conn)
            cur.execute(f"ALTER TABLE {self.out_schema}.{self.out_name}_acces_vals ALTER COLUMN geometry TYPE Geometry(Point, 4326);")
            cur.execute(f"ALTER TABLE {self.out_schema}.{self.out_name}_acces_vals RENAME COLUMN geometry TO geom;") 
            conn.commit()
            cur.close()
            conn.close()
        print(f'access has been measured and exported to: {output_type}')