
DROP TABLE IF EXISTS scratch.input_lines;
CREATE TABLE scratch.input_lines AS
    SELECT
        geom,
        p_key,
        street_name,
        func_class,
        geom_arm,
        geom_centroid,
        geom_seg,
        DEGREES(ST_Azimuth(ST_StartPoint(geom_arm), ST_EndPoint(geom_arm))) AS arm_anlge,
        centroid_seg_angle,
        overall_angle
    FROM (
        SELECT
            geom,
            p_key,
            street_name,
            func_class,
            ST_SetSRID(ST_Translate(ST_Rotate(ST_MakeLine(
                        ST_MakePoint(0.0,-150.0),
                        ST_MakePoint(0.0,150.0)),
                        pi()/2 - ST_Azimuth(ST_StartPoint(geom_seg),ST_EndPoint(geom_seg))),
                    ST_X(geom_centroid),ST_Y(geom_centroid)), 2229) AS geom_arm,
            DEGREES(ST_Azimuth(ST_StartPoint(geom_seg),ST_EndPoint(geom_seg))) AS centroid_seg_angle,
            geom_centroid,
            geom_seg,
            overall_angle
        FROM (
            SELECT
                geom,
                p_key,
                street_name,
                func_class,
                ST_LineInterpolatePoint(geom, 0.5) AS geom_centroid,
                ST_INTERSECTION(geom, ST_BUFFER(ST_LineInterpolatePoint(geom, 0.5), 5)) AS geom_seg,
                DEGREES(ST_Azimuth(ST_StartPoint(geom), ST_EndPoint(geom))) AS overall_angle
            FROM automated.centerlines_la a
            WHERE func_class IN ( 'primary', 'secondary', 'tertiary', 'trunk')
        ) x
    ) x
;

CREATE INDEX sidx_input_lines_geom ON scratch.input_lines USING GIST(geom);
ANALYSE scratch.input_lines(geom);

CREATE INDEX sidx_input_lines_geom_arm ON scratch.input_lines USING GIST(geom_arm);
ANALYSE scratch.input_lines(geom_arm);

DROP TABLE IF EXISTS scratch.dual_lines;
CREATE TABLE scratch.dual_lines AS 
    SELECT
        geom,
        geom_centroid,
        p_key,
        counterpart_p_key,
        street_name,
        counterpart_name,
        name_match,
        name_levenshtein, 
        name_similarity,
        CASE 
            WHEN name_similarity >= 0.7 THEN TRUE 
            ELSE FALSE
            END AS name_similarity_match,
        func_class,
        counterpart_func_class,
        func_class_match,
        overall_angle,
        centroid_seg_angle,
        arm_anlge,
        countpart_arm_intersect_anlge,
        ABS(arm_anlge - countpart_arm_intersect_anlge) AS arm_intersect_angle_diff,
            (ABS(arm_anlge - countpart_arm_intersect_anlge) BETWEEN 90 - 45 AND 90 + 45
            OR
            ABS(arm_anlge - countpart_arm_intersect_anlge) BETWEEN 270 - 45 AND 270 + 45
            ) AS angle_match
    FROM (
        SELECT
            a.p_key,
            a.geom_centroid,
            b.p_key AS counterpart_p_key,
            a.street_name,
            b.street_name AS counterpart_name,
            a.street_name = b.street_name AS name_match,
            levenshtein(a.street_name, b.street_name) AS name_levenshtein,
            similarity(a.street_name, b.street_name) AS name_similarity,
            a.func_class,
            b.func_class AS counterpart_func_class,
            a.func_class = b.func_class AS func_class_match,
            a.geom,
            a.overall_angle,
            a.centroid_seg_angle,
            a.arm_anlge,
            DEGREES(ST_Azimuth(
                        ST_StartPoint(ST_Intersection(b.geom, ST_Buffer(ST_INTERSECTION(a.geom_arm, b.geom), 1))),
                        ST_EndPoint(ST_Intersection(b.geom, ST_Buffer(ST_INTERSECTION(a.geom_arm, b.geom), 1))))
                    ) AS countpart_arm_intersect_anlge
        FROM scratch.input_lines a,
             scratch.input_lines b
        WHERE a.p_key != b.p_key
        AND ST_INTERSECTS(a.geom_arm, b.geom)
    ) x
;

ALTER TABLE scratch.dual_lines
    ADD IF NOT EXISTS bearing_to_counterpart FLOAT,
    ADD IF NOT EXISTS bearing_to_counterpart_relative FLOAT
;

UPDATE scratch.dual_lines a
SET bearing_to_counterpart = x.bearing_to_counterpart,
    bearing_to_counterpart_relative = CASE
        WHEN x.bearing_to_counterpart - x.centroid_seg_angle_180 < 0 THEN x.bearing_to_counterpart - x.centroid_seg_angle_180 + 360
        ELSE x.bearing_to_counterpart - x.centroid_seg_angle_180
        END
FROM
    (SELECT
        a.p_key,
        a.counterpart_p_key,
        CASE
            WHEN a.centroid_seg_angle >= 180 THEN 360 - a.centroid_seg_angle
            ELSE a.centroid_seg_angle
            END AS centroid_seg_angle_180,
        DEGREES(ST_Azimuth(a.geom_centroid,ST_ClosestPoint (b.geom, a.geom_centroid))) AS bearing_to_counterpart
    FROM scratch.dual_lines a
    LEFT JOIN scratch.dual_lines b
    ON a.counterpart_p_key = b.p_key
    ) x
WHERE a.p_key = x.p_key
AND a.counterpart_p_key = x.counterpart_p_key
;

CREATE INDEX sidx_dual_lines ON scratch.dual_lines USING GIST(geom);
ANALYSE scratch.dual_lines(geom)
;

ALTER TABLE scratch.dual_lines
    ADD IF NOT EXISTS tot_match_score INT,
    ADD IF NOT EXISTS manual_match BOOLEAN,
    ADD IF NOT EXISTS side TEXT,
    ADD IF NOT EXISTS side_simple TEXT, 
    ADD IF NOT EXISTS levenshtein INT,
    ADD IF NOT EXISTS similarity FLOAT
;

UPDATE scratch.dual_lines
SET tot_match_score = name_match::INT
                    + func_class_match::INT
                    + angle_match::INT
                    + name_similarity_match::INT,
    manual_match = CASE
        WHEN (name_match OR name_similarity_match) AND func_class_match AND angle_match THEN TRUE -- if all are true, this is a clear dual carriageway
        -- WHEN (name_match OR func_class_match) AND angle_match THEN TRUE -- if the name OR the func_class match (case: when road name changes)
        ELSE FALSE
        END,
    side = CASE
        WHEN countpart_arm_intersect_anlge >= 315 OR countpart_arm_intersect_anlge < 45 THEN 'west'--'north'
        WHEN countpart_arm_intersect_anlge >= 45 AND countpart_arm_intersect_anlge < 135 THEN 'north'--'east'
        WHEN countpart_arm_intersect_anlge >= 135 AND countpart_arm_intersect_anlge < 225 THEN 'east' --'south'
        WHEN countpart_arm_intersect_anlge >= 225 AND countpart_arm_intersect_anlge < 315 THEN 'south' --'west'
        END,
    side_simple = CASE
        WHEN bearing_to_counterpart_relative <= 180 THEN 'left'
        WHEN bearing_to_counterpart_relative > 180 THEN 'right'
        END, 
    levenshtein = levenshtein(street_name, counterpart_name),
    similarity = similarity(street_name, counterpart_name) 
;

ALTER TABLE automated.centerlines_la
    ADD IF NOT EXISTS road_angle FLOAT,
    ADD IF NOT EXISTS dual_carriageway BOOLEAN,
    ADD IF NOT EXISTS road_side TEXT, 
    ADD IF NOT EXISTS dual_match_score INT, 
    ADD IF NOT EXISTS levenshtein INT,
    ADD IF NOT EXISTS similarity FLOAT
;

UPDATE automated.centerlines_la
SET road_angle = NULL,
    dual_carriageway = FALSE,
    road_side = NULL, 
    dual_match_score = NULL, 
    levenshtein = NULL,
    similarity = NULL
;

UPDATE automated.centerlines_la a
SET road_angle = b.overall_angle,
    dual_carriageway = TRUE,
    road_side = b.side_simple, 
    dual_match_score = b.tot_match_score, 
    levenshtein = b.levenshtein, 
    similarity = b.similarity
FROM scratch.dual_lines b
WHERE a.p_key = b.p_key
AND b.manual_match
;
