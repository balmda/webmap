"""
This will eventually be a module that will have a series of functions that will do the following: 
[ ] makes intersections 
[ ] set intersections to/from to segments
[ ] consolidate/dissolve segments between actual intersections
[ ] pg_routing? 
"""

import numpy as np
import os 
from ssr_tools.dbutils.dbutils import *
from psycopg2 import sql
from collections import defaultdict
import networkx as nx
from tqdm import tqdm

class SSRNetwork(DBUtils):
    def __init__(self, road_table, road_geom, road_schema=None, road_pkey=None, 
                int_table=None, no_existing_int = False, int_pkey=None, int_geom=None, int_schema=None, int_srid = None, int_out_schema=None, out_schema=None,
                verbose=True,host='ssrc-db1.c9lbv7c8ir6a.us-east-2.rds.amazonaws.com', db_name=None, user='postgres', password='g.&whu1*Q(Ndsn,j', port='5432'):
        """
        
        Args:

            verbose (bool, optional): Want some outputs to tell you what the script is doing? Yes? Set to true. Else, set to false. Defaults to True.
            host (str, optional): postgres host string. Defaults to 'ssrc-db1.c9lbv7c8ir6a.us-east-2.rds.amazonaws.com'.
            db_name (string, optional): name of the database in which the data is stored and being exported to. Defaults to None.
            user (str, optional): postgres username. Defaults to 'postgres'.
            password (str, optional): _description_. postgres password to 'g.&whu1*Q(Ndsn,j'.
            port (str, optional): postgres port. Defaults to '5432'.
        """
        self.verbose = verbose
        DBUtils.__init__(self, host=host, db_name=db_name, user=user, password=password, port=port,
                         verbose=verbose, filename=__file__)
        
        if self.verbose: print("Setting up SSR_Network object")
        #------------
        # Path and db Stuff
        self.dir = os.path.dirname(os.path.abspath(__file__))
        self.sql_dir = os.path.join(self.dir, 'sql')
        if db_name is None :
            raise ValueError("Need to have schema qualitified road table") 

        if self.verbose: print('setting up basic vars')

        #------------
        # Road setup Stuff
        self.road_schema, self.road = self.parse_table_name(name=road_table)
        if self.road_schema is None :
            raise ValueError("Need to have schema qualitified road table")
        if int_out_schema is None:
            raise ValueError("You need to provide an output schema.")
        else:
            self.int_out_schema = int_out_schema

        self.road_pkey = self.get_pkey(self.road, self.road_schema)
        self.road_geom = road_geom
        self.road_srid = self.find_srid_sql(table=self.road, schema=self.road_schema, geom = self.road_geom)
        if self.verbose: print(f'{self.road} has been loaded')
        
        if int_out_schema is None: 
                ValueError('Provide an intersection output schema.')
        else:
            self.int_out_schema = int_out_schema
        #------------
        # Intersection setup Stuff
        if not no_existing_int:
            if int_table is None: 
                ValueError('Provide an intersection table name, this will serve as the output table name.')
            else:
                self.int_table = int_table
            if int_schema is None: 
                ValueError('Provide an intersection schema name, this will serve as the output schema name.')
            else:
                self.int_schema = int_schema
            if int_pkey is None: 
                ValueError('Provide an intersection unique id name, this will serve as the output pkey name.')
            else: 
                self.int_pkey = int_pkey
            if int_geom is None: 
                ValueError('Provide an intersection geom column name, this will serve as the output geom column name.')
            else: 
                self.int_geom = int_geom
            if int_srid is None: 
                self.int_srid = self.road_srid
        else: 
            self.int_schema, self.int_table = self.parse_table_name(name=int_table)
            if self.int_schema is None :
                raise ValueError("Need to have schema qualitified intersection table")
            self.int_pkey = self.get_pkey(self.int_table, self.int_schema)
            self.int_geom = int_geom
            self.int_srid = self.find_srid_sql(table=self.int_table, schema=self.int_schema, geom = self.int_geom)
            if self.verbose: print(f'{self.int_table} has been loaded')
        
            if self.road_srid != self.int_srid:
                raise ValueError(f"{road} and {int_table} are not of the same SRID.\n{road} SRID: {road_geom}\n{int} SRID: {int_srid}")
            if self.verbose: print('Intersection and Road Table SRIDs match!')
    
        self.sql_subs = {
            'road_schema': sql.SQL(self.road_schema),
            'road': sql.SQL(self.road),
            'road_pkey': sql.Identifier(self.road_pkey),
            'road_geom': sql.SQL(self.road_geom),
            'road_srid': sql.Literal(self.road_srid),
            
            'int_schema': sql.SQL(self.int_schema),
            'int_table': sql.SQL(self.int_table),
            'int_pkey': sql.SQL(self.int_pkey),
            'int_geom': sql.SQL(self.int_geom),
            'int_srid': sql.Literal(self.int_srid),
            
            'int_out_schema': sql.SQL(self.int_out_schema)
        }

    def make_intersections(self, tolerance=None, overwrite=False, assign_to_roads=False, drop_leg_cnt=False, min_legs = 3):
        """this will make an intersection table"""
        
        if self.check_if_multi(table=self.road, schema=self.road_schema, geom=self.road_geom):
            raise ValueError("Sorry, this table need to be a linestring, not multilinestring.")

        # if self.does_table_exists(self.int_table,schema=self.int_schema) and not overwrite:
        #     ValueError('Table already exists and you indicated you did not wnat to overwrite existing table.')

        if tolerance is None:
            self.tolerance = float(input("    You didn't indicate a tolerate, please provide one using spatial unit of your road table: ").strip())
        else:
            self.tolerance = tolerance
        
        if drop_leg_cnt:
            print(f'will drop ints with <= {drop_leg_cnt}')
            self.drop_leg_cnt = drop_leg_cnt
            self.min_legs = min_legs
        else: 
            print('Not dropping any intersections')
            self.drop_leg_cnt = drop_leg_cnt

        self.int_subs = dict(self.sql_subs)
        self.int_subs.update({
            'tolerance': sql.Literal(self.tolerance),
            's_index': sql.Identifier("sidx_" + self.int_table), 
            'geom_literal': sql.Literal(self.int_geom)
            })
        
        if self.verbose: print('making intersections')
        self.execute_sql_script(
            file_name="make_intersections.sql",
            subs=self.int_subs,
            db_name=self.db_name,
            commit_changes=True
            )
        
        if self.drop_leg_cnt: 
            if self.verbose: print('Dropping pseudo intersections')
            self.int_subs = dict(self.int_subs)
            self.int_subs.update({
                'tolerance': sql.Literal(self.tolerance),
                'min_legs': sql.Literal(self.min_legs), 
                })

            self.execute_sql_script(
            file_name="drop_ints.sql",
            subs=self.int_subs,
            db_name=self.db_name,
            commit_changes=True
            )


        if assign_to_roads:
            """this will eventually call the assign_xzy"""
            pass
        print('Okay, done making intersections.')

    def assign_intersections(self, int_table = None, tolerance=None, int_from=None, int_to=None):
        """this will assign intersections to a road table"""
        if int_to is None: 
            self.int_to = 'int_to'
        else: 
            self.int_to = int_to
        if int_from is None: 
            self.int_from = 'int_from'
        else: 
            self.int_from = int_from

        if tolerance is None:
            tolerance = float(input("    You didn't indicate a tolerate, please provide one using spatial unit of your road table: ").strip())

        self.assign_int_subs = dict(self.sql_subs)
        self.assign_int_subs.update({
            'tolerance': sql.Literal(self.tolerance),
            'int_from': sql.SQL(self.int_from),
            'int_to': sql.SQL(self.int_to)
            })

        if self.verbose: print('assign to and from pkeys from intersections to segments')
        self.execute_sql_script(
            file_name="assign_intersections.sql",
            subs=self.assign_int_subs,
            db_name=self.db_name,
            commit_changes=True
            )
        conn = self.create_db_con()[0]
        cur = conn.cursor() 
        qstr = f"""
                SELECT COUNT(*)
                FROM {self.road_schema}.{self.road}
                WHERE {self.int_from} is null OR {self.int_to} is null
                """
        cur.execute(qstr)
        count = cur.fetchone()[0]
        if count > 0:
            warnings.warn("alright, here is how many intersections are missing a to or from intersection id: {:d}".format(count))


    def get_geom_type(self, table, schema=None, geom='geom'):
        """
        Returns the type of the geometry column
        """
        conn = self.create_db_con()[0]
        cur = conn.cursor()
        qstr = f"""
                SELECT DISTINCT geometrytype({geom}) 
                FROM {schema}.{table}
                """
        cur.execute(qstr)
        assert (cur.rowcount == 1), "Whoops, it appears you have more than one geometry type in this table"
        return cur.fetchone()[0]

    def check_if_multi(self, table, schema=None, geom=None):
        """
        checks if a table's geom is multi
        """
        x = self.get_geom_type(table, schema, geom)
        if x.lower()[:5] == "multi":
            print(x.lower())
            return True
        else:
            return False

    def drop_zm_geom(self):
        """this will force geoms to be 2d and drops m"""
        pass

    def flag_dual_carriageways(self, table, p_key, street_name, func_class, distance_threshold, fuzzymatch_min_threshold, crs, 
                               road_filter, save_intermediate_tables=True, intermediate_schema='scratch', intermediate_table='dual_lines', schema=None, geom=None, verbose=True):
        pass 
        if self.check_if_multi(table=self.road, schema=self.road_schema, geom=self.road_geom):
            raise ValueError("Sorry, this table need to be a linestring, not multilinestring.")

    

    