import os
import math
import geopandas as gpd
import pandas as pd
from shapely.geometry import Polygon

class GenUtilities:
    def __init__(self, filename=__file__):
        self.filename = filename
        print(self.filename)

    def module_dir(self):
        """Gets working module directory."""
        return os.path.dirname(os.path.abspath(self.filename))
            
    def get_utm_epsg(self, lat, lng):
        utm_band = str( (math.floor((lng + 180 ) / 6 ) % 60) + 1)
        if len(utm_band) == 1:
            utm_band = '0' + utm_band
        if lat >= 0:
            epsg = '326' + utm_band
        else:
            epsg = '327' + utm_band
        return(epsg)

    def convert_to_utm(self, object):
        # confirm dataframe is a gpds 
        if not isinstance(object, gpd.GeoDataFrame):
            raise ValueError('Your roads object is not a GeoPandas Dataframe.')
        cent_lat = sum(object.centroid.y)/len(object.centroid.y)
        cent_lng = sum(object.centroid.x)/len(object.centroid.x)
        utm = self.get_utm_epsg(cent_lat, cent_lng)
        return(object.to_crs(int(utm)))
    
    def _check_gpds(self, object):
        if isinstance(object, gpd.GeoDataFrame):
            return(True)
        else:
            return(False)

    def _check_is_dict(self, dict):
        if isinstance(object, dict):
            return(True)
        else:
            return(False)

    def _check_col_exists(self, columns, col):
        if col in columns:
            return(True)
        else:
            return(False)    

    def _check_col_dont_exists(self, columns, col):
        if col not in columns:
            return(True)
        else:
            return(False)    

    def _confirm_dict_not_empty(self, _dict):
        if len(_dict) > 0:
            return True
        else:
            return False

    def _get_existing_cols_to_check(self, known_cols=[], unknown_cols=[]):
        cols_exists = known_cols
        for i in unknown_cols:
            if i is not None:
                cols_exists.append(i)
        return cols_exists

    def _bbox_list(self, gpd_df):
        return([i for i in gpd_df.total_bounds])

    def _polygon_from_bbox_list(self, gpd_df):
        bbox = self._bbox_list(gpd_df)
        return Polygon([[bbox[1], bbox[0]],
                        [bbox[1],bbox[2]],
                        [bbox[3],bbox[2]],
                        [bbox[3], bbox[0]]])

    def _return_gpd_df_f_polygon(self, gpd_df, id):
        df = pd.DataFrame({'id': id, 'geometry': self._polygon_from_bbox_list(gpd_df)}, index=[0])
        return ( 
            gpd.GeoDataFrame(df, 
                crs = gpd_df.crs,
                geometry = 'geometry')
                )
    
def feet_to_meters(feet, round_result=False):
    if round_result: 
        return round(feet/3.28084, 2)
    else: 
        return feet/3.28084

def table_style(styler, caption=None, font_size=8,color_ramp='Blues', color_ramp_axis=0, precision=0, color_null=False):
    """Pandas table styles""" 
    if color_ramp is not None:
        styler.background_gradient(axis=color_ramp_axis, cmap=color_ramp)
    if color_null:
        styler.highlight_null(null_color='red')
    if caption is not None:
        styler.set_caption(caption)
    styler.set_precision(precision)
    styler.set_properties(**{'font-size': f'{font_size}pt','text-align': 'center'})
    styler.set_table_styles([{'selector': 'th', 'props' : [('border','.5px solid black !important')]},
                            {'selector': 'td','props' : [('border','.5px solid black !important')]}])
    return styler  

def nice_crosstabs(df, index, columns, values, aggfunc = 'count', table_caption=None, rename_dict=None, style_table=True): 
    """
    function to produce styled crosstabs that includes a frequency count, row percentages, and column percentages. 

    Args:
        df (Pandas DataFrame): the DF that is being used to generate crosstabs
        index (any): index field(s). Need to provide with dataframe, like df_name['colname']
        columns (any): column field(s). Need to provide with dataframe, like df_name['colname']
        values (df.column): the field in which to aggregate the data. syntax = df_nane.colname
        aggfunc (string or list, optional): How the data should be aggregated. Defaults to count. 
        table_caption (string, optional): Add text for the table caption to be displayed above the table. Defaults to None.
        rename_dict (dict, optional): want certain values to be replaced with a different spelling? Do that here. Defaults to None.
        style_table (boolean): do you want the table to have grids and color ramps? Defaults to True. 
    Example: 
        nice_crosstabs(df=crashes_ped, 
                    index=[crashes_ped['city'], crashes_ped['accident_year']], 
                    columns=[crashes_ped['collision_severity_recode']], 
                    caption='testing', 
                    rename_dict=rename_dict
                    )
    """
    cnt = pd.crosstab(index = index, 
                  columns= columns,
                  values= values, 
                  aggfunc=aggfunc, 
                  margins=True, 
                  margins_name='z_Total')

    perc_col = pd.crosstab(index = index, 
                       columns= columns,
                       values= values, 
                       aggfunc=aggfunc,
                       normalize='columns', 
                       margins=True, 
                       margins_name='z_Total').round(4)*100

    perc_row = pd.crosstab(index = index, 
                       columns= columns,
                       values= values, 
                       aggfunc=aggfunc,
                       normalize='index', 
                       margins=True, 
                       margins_name='z_Total').round(4)*100

    output = pd.concat([cnt, perc_col, perc_row], axis = 1, keys = ['n', '%_col', '%_row']).swaplevel(axis = 1)\
                        .sort_index(axis = 1, ascending = [True, False, False])

    if style_table: 
        final_output = output.rename(columns=rename_dict,index={'z_Total': 'Total'}).fillna(100)\
                    .style.pipe(table_style, precision=0, color_null=True, caption = table_caption)
    elif not style_table: 
        print('no caption will be added to the table because you flagged style_table == False')
        final_output = output.rename(columns=rename_dict,index={'z_Total': 'Total'}).fillna(100)
    else: 
        raise ValueError('You need to indicate true of false for style_table')
    
    return final_output

def percent_missing(df, return_dict=False):
    """
    Given a dataframe it calculates the percentage of missing records per column
    Params:
        - df
    Returns:
        - Dictionary of column name and percentage of missing records
    """
    col=list(df.columns)
    perc=[ 'n=' + (df[c].isna().sum() + 0).astype(str) + ' (' + (round(df[c].isna().mean()*100,2)).astype(str) + '%)' for c in col]
    miss_dict=dict(zip(col,perc))
    for key, value in miss_dict.items():
        print(key + ': ' + value)
    if return_dict: 
        return miss_dict

def find_frequency(series, name_index=False, dropna=False):
    """Provide summary on frequency counts and proportions.
    Args:
        series (pandas series): A pandas Series containing discrete values
        name_index (bool, optional): Rename the index to ther target variable, otherwise index is unnamed. Defaults to False.
        dropna (bool, optional): Dropna arg in value_counts(). Defaults to False.
    Return: 
        A pandas DataFrame containing frequency counts and proportions for each
        category.
    """
    def zero_percent(col): 
        if col == '0.0%': 
            return '<0.1%'
        else: 
            return col

    columns = ['%', 'n']
    frequency = pd.concat([(series.value_counts(normalize=True, dropna=dropna) * 100).round(1).astype(str) + '%',
                           series.value_counts(dropna=dropna).map('{:,.0f}'.format)], keys=columns, axis=1)
    if name_index: 
        frequency.index.name = series.name
    
    frequency['%'] = frequency.apply(lambda x: zero_percent(x['%']),axis=1)

    return frequency

def out_transfer_path(folder_name=None, make_dir=True, hard_path=None, project_name=None):
    """Get a common file path to export data to the TRANSFERS folder
    Args:
        hard_path (str, optional): If you need or want to feed in the actual file path to the AWS text file, do it here. Defaults to None.
    """

    ba_company_path = '/Users/balmdale/Dropbox/Company/'
    rs_company_path = '/Users/rebecca/Library/CloudStorage/Dropbox/professional/Consulting/SafeStreetsResearch/Company/'
    js_company_path = '/Users/jessica/Library/CloudStorage/Dropbox/SafeStreetsResearch/Company/'
    
    if folder_name is None: 
        folder_name = ''
    if project_name is None: 
        raise ValueError('Hey, you need to tell me the project name (the main folder name for this project)')
    
    if hard_path is None:
        if os.path.exists(os.path.join(ba_company_path, 'Projects', project_name, 'TRANSFERS')):
            print('Getting out_path via BA path')
            out_path = os.path.join(ba_company_path, 'Projects', project_name, 'TRANSFERS')
            out_path = os.path.join(out_path, folder_name)
            os.makedirs(out_path, exist_ok = True)
        
        elif os.path.exists(os.path.join(js_company_path, 'Projects', project_name, 'TRANSFERS')):
            print('Getting out_path via JS path')
            out_path = os.path.join(js_company_path, 'Projects', project_name, 'TRANSFERS')
            out_path = os.path.join(out_path, folder_name)
            os.makedirs(out_path, exist_ok = True)
        
        elif os.path.exists(os.path.join(rs_company_path, 'Projects', project_name, 'TRANSFERS')):
            print('Getting out_path via RS path')
            out_path = os.path.join(rs_company_path, 'Projects', project_name, 'TRANSFERS')
            out_path = os.path.join(out_path, folder_name)
            os.makedirs(out_path, exist_ok = True)
        
        else: 
            print('Did not get AWS credential.')
    else: 
        out_path = hard_path

    print(out_path)
    return out_path

def kill_file(check_file): 
    try:
        os.remove(check_file)
        print('file deleted')
    except: 
        print('Nope, the file does not exist')

def project_path(project_name=None):
    """Get a common file path to the project folders
    Args:
        hard_path (str, optional): If you need or want to feed in the actual file path to the AWS text file, do it here. Defaults to None.
    """

    ba_company_path = '/Users/balmdale/Dropbox/Company/'
    rs_company_path = '/Users/rebecca/Library/CloudStorage/Dropbox/professional/Consulting/SafeStreetsResearch/Company/'
    js_company_path = '/Users/jessica/Library/CloudStorage/Dropbox/SafeStreetsResearch/Company/'
    
    if project_name is None: 
        raise ValueError('Hey, you need to tell me the project name (the main folder name for this project)')
    
    if os.path.exists(os.path.join(ba_company_path, 'Projects', project_name)):
        print('Getting out_path via BA path')
        out_path = os.path.join(ba_company_path, 'Projects', project_name)
    
    elif os.path.exists(os.path.join(js_company_path, 'Projects', project_name)):
        print('Getting out_path via JS path')
        out_path = os.path.join(js_company_path, 'Projects', project_name)
    
    elif os.path.exists(os.path.join(rs_company_path, 'Projects', project_name)):
        print('Getting out_path via RS path')
        out_path = os.path.join(rs_company_path, 'Projects', project_name)
    
    else: 
        print('Did not get AWS credential.')

    print(out_path)
    return out_path